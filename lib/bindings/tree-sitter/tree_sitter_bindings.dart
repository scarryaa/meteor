// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings to Tree-Sitter
class TreeSitter {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
  _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  TreeSitter(ffi.DynamicLibrary dynamicLibrary)
    : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  TreeSitter.fromLookup(
    ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) lookup,
  ) : _lookup = lookup;

  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> signal(
    int arg0,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> arg1,
  ) {
    return _signal(arg0, arg1);
  }

  late final _signalPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> Function(
        ffi.Int,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>,
      )
    >
  >('signal');
  late final _signal =
      _signalPtr
          .asFunction<
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>
            Function(
              int,
              ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>,
            )
          >();

  int getpriority(int arg0, int arg1) {
    return _getpriority(arg0, arg1);
  }

  late final _getpriorityPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, id_t)>>(
        'getpriority',
      );
  late final _getpriority =
      _getpriorityPtr.asFunction<int Function(int, int)>();

  int getiopolicy_np(int arg0, int arg1) {
    return _getiopolicy_np(arg0, arg1);
  }

  late final _getiopolicy_npPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
        'getiopolicy_np',
      );
  late final _getiopolicy_np =
      _getiopolicy_npPtr.asFunction<int Function(int, int)>();

  int getrlimit(int arg0, ffi.Pointer<rlimit> arg1) {
    return _getrlimit(arg0, arg1);
  }

  late final _getrlimitPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<rlimit>)>
  >('getrlimit');
  late final _getrlimit =
      _getrlimitPtr.asFunction<int Function(int, ffi.Pointer<rlimit>)>();

  int getrusage(int arg0, ffi.Pointer<rusage> arg1) {
    return _getrusage(arg0, arg1);
  }

  late final _getrusagePtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<rusage>)>
  >('getrusage');
  late final _getrusage =
      _getrusagePtr.asFunction<int Function(int, ffi.Pointer<rusage>)>();

  int setpriority(int arg0, int arg1, int arg2) {
    return _setpriority(arg0, arg1, arg2);
  }

  late final _setpriorityPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, id_t, ffi.Int)>>(
        'setpriority',
      );
  late final _setpriority =
      _setpriorityPtr.asFunction<int Function(int, int, int)>();

  int setiopolicy_np(int arg0, int arg1, int arg2) {
    return _setiopolicy_np(arg0, arg1, arg2);
  }

  late final _setiopolicy_npPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>(
        'setiopolicy_np',
      );
  late final _setiopolicy_np =
      _setiopolicy_npPtr.asFunction<int Function(int, int, int)>();

  int setrlimit(int arg0, ffi.Pointer<rlimit> arg1) {
    return _setrlimit(arg0, arg1);
  }

  late final _setrlimitPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<rlimit>)>
  >('setrlimit');
  late final _setrlimit =
      _setrlimitPtr.asFunction<int Function(int, ffi.Pointer<rlimit>)>();

  int wait1(ffi.Pointer<ffi.Int> arg0) {
    return _wait1(arg0);
  }

  late final _wait1Ptr =
      _lookup<ffi.NativeFunction<pid_t Function(ffi.Pointer<ffi.Int>)>>('wait');
  late final _wait1 =
      _wait1Ptr.asFunction<int Function(ffi.Pointer<ffi.Int>)>();

  int waitpid(int arg0, ffi.Pointer<ffi.Int> arg1, int arg2) {
    return _waitpid(arg0, arg1, arg2);
  }

  late final _waitpidPtr = _lookup<
    ffi.NativeFunction<pid_t Function(pid_t, ffi.Pointer<ffi.Int>, ffi.Int)>
  >('waitpid');
  late final _waitpid =
      _waitpidPtr.asFunction<int Function(int, ffi.Pointer<ffi.Int>, int)>();

  int waitid(
    idtype_t arg0,
    Dart__uint32_t arg1,
    ffi.Pointer<siginfo_t> arg2,
    int arg3,
  ) {
    return _waitid(arg0.value, arg1, arg2, arg3);
  }

  late final _waitidPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.UnsignedInt, id_t, ffi.Pointer<siginfo_t>, ffi.Int)
    >
  >('waitid');
  late final _waitid =
      _waitidPtr
          .asFunction<int Function(int, int, ffi.Pointer<siginfo_t>, int)>();

  int wait3(ffi.Pointer<ffi.Int> arg0, int arg1, ffi.Pointer<rusage> arg2) {
    return _wait3(arg0, arg1, arg2);
  }

  late final _wait3Ptr = _lookup<
    ffi.NativeFunction<
      pid_t Function(ffi.Pointer<ffi.Int>, ffi.Int, ffi.Pointer<rusage>)
    >
  >('wait3');
  late final _wait3 =
      _wait3Ptr
          .asFunction<
            int Function(ffi.Pointer<ffi.Int>, int, ffi.Pointer<rusage>)
          >();

  int wait4(
    int arg0,
    ffi.Pointer<ffi.Int> arg1,
    int arg2,
    ffi.Pointer<rusage> arg3,
  ) {
    return _wait4(arg0, arg1, arg2, arg3);
  }

  late final _wait4Ptr = _lookup<
    ffi.NativeFunction<
      pid_t Function(pid_t, ffi.Pointer<ffi.Int>, ffi.Int, ffi.Pointer<rusage>)
    >
  >('wait4');
  late final _wait4 =
      _wait4Ptr
          .asFunction<
            int Function(int, ffi.Pointer<ffi.Int>, int, ffi.Pointer<rusage>)
          >();

  ffi.Pointer<ffi.Void> alloca(int arg0) {
    return _alloca(arg0);
  }

  late final _allocaPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
        'alloca',
      );
  late final _alloca =
      _allocaPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  late final ffi.Pointer<ffi.Int> ___mb_cur_max = _lookup<ffi.Int>(
    '__mb_cur_max',
  );

  int get __mb_cur_max => ___mb_cur_max.value;

  set __mb_cur_max(int value) => ___mb_cur_max.value = value;

  ffi.Pointer<ffi.Void> malloc_type_malloc(int size, int type_id) {
    return _malloc_type_malloc(size, type_id);
  }

  late final _malloc_type_mallocPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Size, malloc_type_id_t)
    >
  >('malloc_type_malloc');
  late final _malloc_type_malloc =
      _malloc_type_mallocPtr
          .asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_calloc(int count, int size, int type_id) {
    return _malloc_type_calloc(count, size, type_id);
  }

  late final _malloc_type_callocPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size, malloc_type_id_t)
    >
  >('malloc_type_calloc');
  late final _malloc_type_calloc =
      _malloc_type_callocPtr
          .asFunction<ffi.Pointer<ffi.Void> Function(int, int, int)>();

  void malloc_type_free(ffi.Pointer<ffi.Void> ptr, int type_id) {
    return _malloc_type_free(ptr, type_id);
  }

  late final _malloc_type_freePtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<ffi.Void>, malloc_type_id_t)
    >
  >('malloc_type_free');
  late final _malloc_type_free =
      _malloc_type_freePtr
          .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> malloc_type_realloc(
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int type_id,
  ) {
    return _malloc_type_realloc(ptr, size, type_id);
  }

  late final _malloc_type_reallocPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<ffi.Void> Function(
        ffi.Pointer<ffi.Void>,
        ffi.Size,
        malloc_type_id_t,
      )
    >
  >('malloc_type_realloc');
  late final _malloc_type_realloc =
      _malloc_type_reallocPtr
          .asFunction<
            ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)
          >();

  ffi.Pointer<ffi.Void> malloc_type_valloc(int size, int type_id) {
    return _malloc_type_valloc(size, type_id);
  }

  late final _malloc_type_vallocPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Size, malloc_type_id_t)
    >
  >('malloc_type_valloc');
  late final _malloc_type_valloc =
      _malloc_type_vallocPtr
          .asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_aligned_alloc(
    int alignment,
    int size,
    int type_id,
  ) {
    return _malloc_type_aligned_alloc(alignment, size, type_id);
  }

  late final _malloc_type_aligned_allocPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size, malloc_type_id_t)
    >
  >('malloc_type_aligned_alloc');
  late final _malloc_type_aligned_alloc =
      _malloc_type_aligned_allocPtr
          .asFunction<ffi.Pointer<ffi.Void> Function(int, int, int)>();

  int malloc_type_posix_memalign(
    ffi.Pointer<ffi.Pointer<ffi.Void>> memptr,
    int alignment,
    int size,
    int type_id,
  ) {
    return _malloc_type_posix_memalign(memptr, alignment, size, type_id);
  }

  late final _malloc_type_posix_memalignPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<ffi.Pointer<ffi.Void>>,
        ffi.Size,
        ffi.Size,
        malloc_type_id_t,
      )
    >
  >('malloc_type_posix_memalign');
  late final _malloc_type_posix_memalign =
      _malloc_type_posix_memalignPtr
          .asFunction<
            int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, int, int, int)
          >();

  ffi.Pointer<ffi.Void> malloc_type_zone_malloc(
    ffi.Pointer<malloc_zone_t> zone,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_malloc(zone, size, type_id);
  }

  late final _malloc_type_zone_mallocPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<ffi.Void> Function(
        ffi.Pointer<malloc_zone_t>,
        ffi.Size,
        malloc_type_id_t,
      )
    >
  >('malloc_type_zone_malloc');
  late final _malloc_type_zone_malloc =
      _malloc_type_zone_mallocPtr
          .asFunction<
            ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, int, int)
          >();

  ffi.Pointer<ffi.Void> malloc_type_zone_calloc(
    ffi.Pointer<malloc_zone_t> zone,
    int count,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_calloc(zone, count, size, type_id);
  }

  late final _malloc_type_zone_callocPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<ffi.Void> Function(
        ffi.Pointer<malloc_zone_t>,
        ffi.Size,
        ffi.Size,
        malloc_type_id_t,
      )
    >
  >('malloc_type_zone_calloc');
  late final _malloc_type_zone_calloc =
      _malloc_type_zone_callocPtr
          .asFunction<
            ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<malloc_zone_t>,
              int,
              int,
              int,
            )
          >();

  void malloc_type_zone_free(
    ffi.Pointer<malloc_zone_t> zone,
    ffi.Pointer<ffi.Void> ptr,
    int type_id,
  ) {
    return _malloc_type_zone_free(zone, ptr, type_id);
  }

  late final _malloc_type_zone_freePtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(
        ffi.Pointer<malloc_zone_t>,
        ffi.Pointer<ffi.Void>,
        malloc_type_id_t,
      )
    >
  >('malloc_type_zone_free');
  late final _malloc_type_zone_free =
      _malloc_type_zone_freePtr
          .asFunction<
            void Function(
              ffi.Pointer<malloc_zone_t>,
              ffi.Pointer<ffi.Void>,
              int,
            )
          >();

  ffi.Pointer<ffi.Void> malloc_type_zone_realloc(
    ffi.Pointer<malloc_zone_t> zone,
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_realloc(zone, ptr, size, type_id);
  }

  late final _malloc_type_zone_reallocPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<ffi.Void> Function(
        ffi.Pointer<malloc_zone_t>,
        ffi.Pointer<ffi.Void>,
        ffi.Size,
        malloc_type_id_t,
      )
    >
  >('malloc_type_zone_realloc');
  late final _malloc_type_zone_realloc =
      _malloc_type_zone_reallocPtr
          .asFunction<
            ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<malloc_zone_t>,
              ffi.Pointer<ffi.Void>,
              int,
              int,
            )
          >();

  ffi.Pointer<ffi.Void> malloc_type_zone_valloc(
    ffi.Pointer<malloc_zone_t> zone,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_valloc(zone, size, type_id);
  }

  late final _malloc_type_zone_vallocPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<ffi.Void> Function(
        ffi.Pointer<malloc_zone_t>,
        ffi.Size,
        malloc_type_id_t,
      )
    >
  >('malloc_type_zone_valloc');
  late final _malloc_type_zone_valloc =
      _malloc_type_zone_vallocPtr
          .asFunction<
            ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, int, int)
          >();

  ffi.Pointer<ffi.Void> malloc_type_zone_memalign(
    ffi.Pointer<malloc_zone_t> zone,
    int alignment,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_memalign(zone, alignment, size, type_id);
  }

  late final _malloc_type_zone_memalignPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<ffi.Void> Function(
        ffi.Pointer<malloc_zone_t>,
        ffi.Size,
        ffi.Size,
        malloc_type_id_t,
      )
    >
  >('malloc_type_zone_memalign');
  late final _malloc_type_zone_memalign =
      _malloc_type_zone_memalignPtr
          .asFunction<
            ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<malloc_zone_t>,
              int,
              int,
              int,
            )
          >();

  ffi.Pointer<ffi.Void> malloc(int __size) {
    return _malloc(__size);
  }

  late final _mallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
        'malloc',
      );
  late final _malloc =
      _mallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> calloc(int __count, int __size) {
    return _calloc(__count, __size);
  }

  late final _callocPtr = _lookup<
    ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>
  >('calloc');
  late final _calloc =
      _callocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  void free(ffi.Pointer<ffi.Void> arg0) {
    return _free(arg0);
  }

  late final _freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
        'free',
      );
  late final _free =
      _freePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> realloc(ffi.Pointer<ffi.Void> __ptr, int __size) {
    return _realloc(__ptr, __size);
  }

  late final _reallocPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Size)
    >
  >('realloc');
  late final _realloc =
      _reallocPtr
          .asFunction<
            ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)
          >();

  ffi.Pointer<ffi.Void> reallocf(ffi.Pointer<ffi.Void> __ptr, int __size) {
    return _reallocf(__ptr, __size);
  }

  late final _reallocfPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Size)
    >
  >('reallocf');
  late final _reallocf =
      _reallocfPtr
          .asFunction<
            ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)
          >();

  ffi.Pointer<ffi.Void> valloc(int __size) {
    return _valloc(__size);
  }

  late final _vallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
        'valloc',
      );
  late final _valloc =
      _vallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> aligned_alloc(int __alignment, int __size) {
    return _aligned_alloc(__alignment, __size);
  }

  late final _aligned_allocPtr = _lookup<
    ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>
  >('aligned_alloc');
  late final _aligned_alloc =
      _aligned_allocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  int posix_memalign(
    ffi.Pointer<ffi.Pointer<ffi.Void>> __memptr,
    int __alignment,
    int __size,
  ) {
    return _posix_memalign(__memptr, __alignment, __size);
  }

  late final _posix_memalignPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Size, ffi.Size)
    >
  >('posix_memalign');
  late final _posix_memalign =
      _posix_memalignPtr
          .asFunction<
            int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, int, int)
          >();

  void abort() {
    return _abort();
  }

  late final _abortPtr = _lookup<ffi.NativeFunction<ffi.Void Function()>>(
    'abort',
  );
  late final _abort = _abortPtr.asFunction<void Function()>();

  int abs(int arg0) {
    return _abs(arg0);
  }

  late final _absPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
    'abs',
  );
  late final _abs = _absPtr.asFunction<int Function(int)>();

  int atexit(ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> arg0) {
    return _atexit(arg0);
  }

  late final _atexitPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)
    >
  >('atexit');
  late final _atexit =
      _atexitPtr
          .asFunction<
            int Function(ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)
          >();

  int at_quick_exit(ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> arg0) {
    return _at_quick_exit(arg0);
  }

  late final _at_quick_exitPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)
    >
  >('at_quick_exit');
  late final _at_quick_exit =
      _at_quick_exitPtr
          .asFunction<
            int Function(ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)
          >();

  double atof(ffi.Pointer<ffi.Char> arg0) {
    return _atof(arg0);
  }

  late final _atofPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
        'atof',
      );
  late final _atof =
      _atofPtr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int atoi(ffi.Pointer<ffi.Char> arg0) {
    return _atoi(arg0);
  }

  late final _atoiPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
        'atoi',
      );
  late final _atoi = _atoiPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int atol(ffi.Pointer<ffi.Char> arg0) {
    return _atol(arg0);
  }

  late final _atolPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Char>)>>(
        'atol',
      );
  late final _atol = _atolPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int atoll(ffi.Pointer<ffi.Char> arg0) {
    return _atoll(arg0);
  }

  late final _atollPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.Pointer<ffi.Char>)>>(
        'atoll',
      );
  late final _atoll =
      _atollPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Void> bsearch(
    ffi.Pointer<ffi.Void> __key,
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)
      >
    >
    __compar,
  ) {
    return _bsearch(__key, __base, __nel, __width, __compar);
  }

  late final _bsearchPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<ffi.Void> Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<ffi.Void>,
        ffi.Size,
        ffi.Size,
        ffi.Pointer<
          ffi.NativeFunction<
            ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)
          >
        >,
      )
    >
  >('bsearch');
  late final _bsearch =
      _bsearchPtr
          .asFunction<
            ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              ffi.Pointer<
                ffi.NativeFunction<
                  ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)
                >
              >,
            )
          >();

  div_t div(int arg0, int arg1) {
    return _div(arg0, arg1);
  }

  late final _divPtr =
      _lookup<ffi.NativeFunction<div_t Function(ffi.Int, ffi.Int)>>('div');
  late final _div = _divPtr.asFunction<div_t Function(int, int)>();

  void exit(int arg0) {
    return _exit(arg0);
  }

  late final _exitPtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>(
    'exit',
  );
  late final _exit = _exitPtr.asFunction<void Function(int)>();

  ffi.Pointer<ffi.Char> getenv(ffi.Pointer<ffi.Char> arg0) {
    return _getenv(arg0);
  }

  late final _getenvPtr = _lookup<
    ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>
  >('getenv');
  late final _getenv =
      _getenvPtr
          .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int labs(int arg0) {
    return _labs(arg0);
  }

  late final _labsPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Long)>>('labs');
  late final _labs = _labsPtr.asFunction<int Function(int)>();

  ldiv_t ldiv(int arg0, int arg1) {
    return _ldiv(arg0, arg1);
  }

  late final _ldivPtr =
      _lookup<ffi.NativeFunction<ldiv_t Function(ffi.Long, ffi.Long)>>('ldiv');
  late final _ldiv = _ldivPtr.asFunction<ldiv_t Function(int, int)>();

  int llabs(int arg0) {
    return _llabs(arg0);
  }

  late final _llabsPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.LongLong)>>('llabs');
  late final _llabs = _llabsPtr.asFunction<int Function(int)>();

  lldiv_t lldiv(int arg0, int arg1) {
    return _lldiv(arg0, arg1);
  }

  late final _lldivPtr =
      _lookup<ffi.NativeFunction<lldiv_t Function(ffi.LongLong, ffi.LongLong)>>(
        'lldiv',
      );
  late final _lldiv = _lldivPtr.asFunction<lldiv_t Function(int, int)>();

  int mblen(ffi.Pointer<ffi.Char> __s, int __n) {
    return _mblen(__s, __n);
  }

  late final _mblenPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size)>
  >('mblen');
  late final _mblen =
      _mblenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int mbstowcs(
    ffi.Pointer<ffi.WChar> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _mbstowcs(arg0, arg1, arg2);
  }

  late final _mbstowcsPtr = _lookup<
    ffi.NativeFunction<
      ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>, ffi.Size)
    >
  >('mbstowcs');
  late final _mbstowcs =
      _mbstowcsPtr
          .asFunction<
            int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>, int)
          >();

  int mbtowc(
    ffi.Pointer<ffi.WChar> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _mbtowc(arg0, arg1, arg2);
  }

  late final _mbtowcPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>, ffi.Size)
    >
  >('mbtowc');
  late final _mbtowc =
      _mbtowcPtr
          .asFunction<
            int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>, int)
          >();

  void qsort(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)
      >
    >
    __compar,
  ) {
    return _qsort(__base, __nel, __width, __compar);
  }

  late final _qsortPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Size,
        ffi.Size,
        ffi.Pointer<
          ffi.NativeFunction<
            ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)
          >
        >,
      )
    >
  >('qsort');
  late final _qsort =
      _qsortPtr
          .asFunction<
            void Function(
              ffi.Pointer<ffi.Void>,
              int,
              int,
              ffi.Pointer<
                ffi.NativeFunction<
                  ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)
                >
              >,
            )
          >();

  void quick_exit(int arg0) {
    return _quick_exit(arg0);
  }

  late final _quick_exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('quick_exit');
  late final _quick_exit = _quick_exitPtr.asFunction<void Function(int)>();

  int rand() {
    return _rand();
  }

  late final _randPtr = _lookup<ffi.NativeFunction<ffi.Int Function()>>('rand');
  late final _rand = _randPtr.asFunction<int Function()>();

  void srand(int arg0) {
    return _srand(arg0);
  }

  late final _srandPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>('srand');
  late final _srand = _srandPtr.asFunction<void Function(int)>();

  double strtod(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ) {
    return _strtod(arg0, arg1);
  }

  late final _strtodPtr = _lookup<
    ffi.NativeFunction<
      ffi.Double Function(
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Pointer<ffi.Char>>,
      )
    >
  >('strtod');
  late final _strtod =
      _strtodPtr
          .asFunction<
            double Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
            )
          >();

  double strtof(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ) {
    return _strtof(arg0, arg1);
  }

  late final _strtofPtr = _lookup<
    ffi.NativeFunction<
      ffi.Float Function(
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Pointer<ffi.Char>>,
      )
    >
  >('strtof');
  late final _strtof =
      _strtofPtr
          .asFunction<
            double Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
            )
          >();

  int strtol(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtol(__str, __endptr, __base);
  }

  late final _strtolPtr = _lookup<
    ffi.NativeFunction<
      ffi.Long Function(
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Pointer<ffi.Char>>,
        ffi.Int,
      )
    >
  >('strtol');
  late final _strtol =
      _strtolPtr
          .asFunction<
            int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              int,
            )
          >();

  int strtoll(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoll(__str, __endptr, __base);
  }

  late final _strtollPtr = _lookup<
    ffi.NativeFunction<
      ffi.LongLong Function(
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Pointer<ffi.Char>>,
        ffi.Int,
      )
    >
  >('strtoll');
  late final _strtoll =
      _strtollPtr
          .asFunction<
            int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              int,
            )
          >();

  int strtoul(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoul(__str, __endptr, __base);
  }

  late final _strtoulPtr = _lookup<
    ffi.NativeFunction<
      ffi.UnsignedLong Function(
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Pointer<ffi.Char>>,
        ffi.Int,
      )
    >
  >('strtoul');
  late final _strtoul =
      _strtoulPtr
          .asFunction<
            int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              int,
            )
          >();

  int strtoull(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoull(__str, __endptr, __base);
  }

  late final _strtoullPtr = _lookup<
    ffi.NativeFunction<
      ffi.UnsignedLongLong Function(
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Pointer<ffi.Char>>,
        ffi.Int,
      )
    >
  >('strtoull');
  late final _strtoull =
      _strtoullPtr
          .asFunction<
            int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              int,
            )
          >();

  int system(ffi.Pointer<ffi.Char> arg0) {
    return _system(arg0);
  }

  late final _systemPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
        'system',
      );
  late final _system =
      _systemPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int wcstombs(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.WChar> arg1,
    int arg2,
  ) {
    return _wcstombs(arg0, arg1, arg2);
  }

  late final _wcstombsPtr = _lookup<
    ffi.NativeFunction<
      ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.WChar>, ffi.Size)
    >
  >('wcstombs');
  late final _wcstombs =
      _wcstombsPtr
          .asFunction<
            int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.WChar>, int)
          >();

  int wctomb(ffi.Pointer<ffi.Char> arg0, int arg1) {
    return _wctomb(arg0, arg1);
  }

  late final _wctombPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.WChar)>
  >('wctomb');
  late final _wctomb =
      _wctombPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  void _Exit(int arg0) {
    return __Exit(arg0);
  }

  late final __ExitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('_Exit');
  late final __Exit = __ExitPtr.asFunction<void Function(int)>();

  int a64l(ffi.Pointer<ffi.Char> arg0) {
    return _a64l(arg0);
  }

  late final _a64lPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Char>)>>(
        'a64l',
      );
  late final _a64l = _a64lPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double drand48() {
    return _drand48();
  }

  late final _drand48Ptr = _lookup<ffi.NativeFunction<ffi.Double Function()>>(
    'drand48',
  );
  late final _drand48 = _drand48Ptr.asFunction<double Function()>();

  ffi.Pointer<ffi.Char> ecvt(
    double arg0,
    int arg1,
    ffi.Pointer<ffi.Int> arg2,
    ffi.Pointer<ffi.Int> arg3,
  ) {
    return _ecvt(arg0, arg1, arg2, arg3);
  }

  late final _ecvtPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<ffi.Char> Function(
        ffi.Double,
        ffi.Int,
        ffi.Pointer<ffi.Int>,
        ffi.Pointer<ffi.Int>,
      )
    >
  >('ecvt');
  late final _ecvt =
      _ecvtPtr
          .asFunction<
            ffi.Pointer<ffi.Char> Function(
              double,
              int,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
            )
          >();

  double erand48(ffi.Pointer<ffi.UnsignedShort> arg0) {
    return _erand48(arg0);
  }

  late final _erand48Ptr = _lookup<
    ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.UnsignedShort>)>
  >('erand48');
  late final _erand48 =
      _erand48Ptr.asFunction<double Function(ffi.Pointer<ffi.UnsignedShort>)>();

  ffi.Pointer<ffi.Char> fcvt(
    double arg0,
    int arg1,
    ffi.Pointer<ffi.Int> arg2,
    ffi.Pointer<ffi.Int> arg3,
  ) {
    return _fcvt(arg0, arg1, arg2, arg3);
  }

  late final _fcvtPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<ffi.Char> Function(
        ffi.Double,
        ffi.Int,
        ffi.Pointer<ffi.Int>,
        ffi.Pointer<ffi.Int>,
      )
    >
  >('fcvt');
  late final _fcvt =
      _fcvtPtr
          .asFunction<
            ffi.Pointer<ffi.Char> Function(
              double,
              int,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
            )
          >();

  ffi.Pointer<ffi.Char> gcvt(
    double arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
  ) {
    return _gcvt(arg0, arg1, arg2);
  }

  late final _gcvtPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Double, ffi.Int, ffi.Pointer<ffi.Char>)
    >
  >('gcvt');
  late final _gcvt =
      _gcvtPtr
          .asFunction<
            ffi.Pointer<ffi.Char> Function(double, int, ffi.Pointer<ffi.Char>)
          >();

  int getsubopt(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg2,
  ) {
    return _getsubopt(arg0, arg1, arg2);
  }

  late final _getsuboptPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<ffi.Pointer<ffi.Char>>,
        ffi.Pointer<ffi.Pointer<ffi.Char>>,
        ffi.Pointer<ffi.Pointer<ffi.Char>>,
      )
    >
  >('getsubopt');
  late final _getsubopt =
      _getsuboptPtr
          .asFunction<
            int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
            )
          >();

  int grantpt(int arg0) {
    return _grantpt(arg0);
  }

  late final _grantptPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('grantpt');
  late final _grantpt = _grantptPtr.asFunction<int Function(int)>();

  ffi.Pointer<ffi.Char> initstate(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _initstate(arg0, arg1, arg2);
  }

  late final _initstatePtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<ffi.Char> Function(
        ffi.UnsignedInt,
        ffi.Pointer<ffi.Char>,
        ffi.Size,
      )
    >
  >('initstate');
  late final _initstate =
      _initstatePtr
          .asFunction<
            ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)
          >();

  int jrand48(ffi.Pointer<ffi.UnsignedShort> arg0) {
    return _jrand48(arg0);
  }

  late final _jrand48Ptr = _lookup<
    ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.UnsignedShort>)>
  >('jrand48');
  late final _jrand48 =
      _jrand48Ptr.asFunction<int Function(ffi.Pointer<ffi.UnsignedShort>)>();

  ffi.Pointer<ffi.Char> l64a(int arg0) {
    return _l64a(arg0);
  }

  late final _l64aPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Long)>>(
        'l64a',
      );
  late final _l64a = _l64aPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  void lcong48(ffi.Pointer<ffi.UnsignedShort> arg0) {
    return _lcong48(arg0);
  }

  late final _lcong48Ptr = _lookup<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.UnsignedShort>)>
  >('lcong48');
  late final _lcong48 =
      _lcong48Ptr.asFunction<void Function(ffi.Pointer<ffi.UnsignedShort>)>();

  int lrand48() {
    return _lrand48();
  }

  late final _lrand48Ptr = _lookup<ffi.NativeFunction<ffi.Long Function()>>(
    'lrand48',
  );
  late final _lrand48 = _lrand48Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> mktemp(ffi.Pointer<ffi.Char> arg0) {
    return _mktemp(arg0);
  }

  late final _mktempPtr = _lookup<
    ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>
  >('mktemp');
  late final _mktemp =
      _mktempPtr
          .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int mkstemp(ffi.Pointer<ffi.Char> arg0) {
    return _mkstemp(arg0);
  }

  late final _mkstempPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
        'mkstemp',
      );
  late final _mkstemp =
      _mkstempPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int mrand48() {
    return _mrand48();
  }

  late final _mrand48Ptr = _lookup<ffi.NativeFunction<ffi.Long Function()>>(
    'mrand48',
  );
  late final _mrand48 = _mrand48Ptr.asFunction<int Function()>();

  int nrand48(ffi.Pointer<ffi.UnsignedShort> arg0) {
    return _nrand48(arg0);
  }

  late final _nrand48Ptr = _lookup<
    ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.UnsignedShort>)>
  >('nrand48');
  late final _nrand48 =
      _nrand48Ptr.asFunction<int Function(ffi.Pointer<ffi.UnsignedShort>)>();

  int posix_openpt(int arg0) {
    return _posix_openpt(arg0);
  }

  late final _posix_openptPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('posix_openpt');
  late final _posix_openpt = _posix_openptPtr.asFunction<int Function(int)>();

  ffi.Pointer<ffi.Char> ptsname(int arg0) {
    return _ptsname(arg0);
  }

  late final _ptsnamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
        'ptsname',
      );
  late final _ptsname =
      _ptsnamePtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int ptsname_r(int fildes, ffi.Pointer<ffi.Char> buffer, int buflen) {
    return _ptsname_r(fildes, buffer, buflen);
  }

  late final _ptsname_rPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.Size)
    >
  >('ptsname_r');
  late final _ptsname_r =
      _ptsname_rPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  int putenv(ffi.Pointer<ffi.Char> arg0) {
    return _putenv(arg0);
  }

  late final _putenvPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
        'putenv',
      );
  late final _putenv =
      _putenvPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int random() {
    return _random();
  }

  late final _randomPtr = _lookup<ffi.NativeFunction<ffi.Long Function()>>(
    'random',
  );
  late final _random = _randomPtr.asFunction<int Function()>();

  int rand_r(ffi.Pointer<ffi.UnsignedInt> arg0) {
    return _rand_r(arg0);
  }

  late final _rand_rPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.UnsignedInt>)>
  >('rand_r');
  late final _rand_r =
      _rand_rPtr.asFunction<int Function(ffi.Pointer<ffi.UnsignedInt>)>();

  ffi.Pointer<ffi.Char> realpath(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _realpath(arg0, arg1);
  }

  late final _realpathPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<ffi.Char> Function(
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Char>,
      )
    >
  >('realpath');
  late final _realpath =
      _realpathPtr
          .asFunction<
            ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
            )
          >();

  ffi.Pointer<ffi.UnsignedShort> seed48(ffi.Pointer<ffi.UnsignedShort> arg0) {
    return _seed48(arg0);
  }

  late final _seed48Ptr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<ffi.UnsignedShort> Function(ffi.Pointer<ffi.UnsignedShort>)
    >
  >('seed48');
  late final _seed48 =
      _seed48Ptr
          .asFunction<
            ffi.Pointer<ffi.UnsignedShort> Function(
              ffi.Pointer<ffi.UnsignedShort>,
            )
          >();

  int setenv(
    ffi.Pointer<ffi.Char> __name,
    ffi.Pointer<ffi.Char> __value,
    int __overwrite,
  ) {
    return _setenv(__name, __value, __overwrite);
  }

  late final _setenvPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, ffi.Int)
    >
  >('setenv');
  late final _setenv =
      _setenvPtr
          .asFunction<
            int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)
          >();

  void setkey(ffi.Pointer<ffi.Char> arg0) {
    return _setkey(arg0);
  }

  late final _setkeyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
        'setkey',
      );
  late final _setkey =
      _setkeyPtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> setstate(ffi.Pointer<ffi.Char> arg0) {
    return _setstate(arg0);
  }

  late final _setstatePtr = _lookup<
    ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>
  >('setstate');
  late final _setstate =
      _setstatePtr
          .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  void srand48(int arg0) {
    return _srand48(arg0);
  }

  late final _srand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Long)>>('srand48');
  late final _srand48 = _srand48Ptr.asFunction<void Function(int)>();

  void srandom(int arg0) {
    return _srandom(arg0);
  }

  late final _srandomPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>(
        'srandom',
      );
  late final _srandom = _srandomPtr.asFunction<void Function(int)>();

  int unlockpt(int arg0) {
    return _unlockpt(arg0);
  }

  late final _unlockptPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('unlockpt');
  late final _unlockpt = _unlockptPtr.asFunction<int Function(int)>();

  int unsetenv(ffi.Pointer<ffi.Char> arg0) {
    return _unsetenv(arg0);
  }

  late final _unsetenvPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
        'unsetenv',
      );
  late final _unsetenv =
      _unsetenvPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int arc4random() {
    return _arc4random();
  }

  late final _arc4randomPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function()>>('arc4random');
  late final _arc4random = _arc4randomPtr.asFunction<int Function()>();

  void arc4random_addrandom(ffi.Pointer<ffi.UnsignedChar> arg0, int arg1) {
    return _arc4random_addrandom(arg0, arg1);
  }

  late final _arc4random_addrandomPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<ffi.UnsignedChar>, ffi.Int)
    >
  >('arc4random_addrandom');
  late final _arc4random_addrandom =
      _arc4random_addrandomPtr
          .asFunction<void Function(ffi.Pointer<ffi.UnsignedChar>, int)>();

  void arc4random_buf(ffi.Pointer<ffi.Void> __buf, int __nbytes) {
    return _arc4random_buf(__buf, __nbytes);
  }

  late final _arc4random_bufPtr = _lookup<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Size)>
  >('arc4random_buf');
  late final _arc4random_buf =
      _arc4random_bufPtr
          .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  void arc4random_stir() {
    return _arc4random_stir();
  }

  late final _arc4random_stirPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('arc4random_stir');
  late final _arc4random_stir =
      _arc4random_stirPtr.asFunction<void Function()>();

  int arc4random_uniform(int __upper_bound) {
    return _arc4random_uniform(__upper_bound);
  }

  late final _arc4random_uniformPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Uint32)>>(
        'arc4random_uniform',
      );
  late final _arc4random_uniform =
      _arc4random_uniformPtr.asFunction<int Function(int)>();

  ffi.Pointer<ffi.Char> cgetcap(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _cgetcap(arg0, arg1, arg2);
  }

  late final _cgetcapPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<ffi.Char> Function(
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Char>,
        ffi.Int,
      )
    >
  >('cgetcap');
  late final _cgetcap =
      _cgetcapPtr
          .asFunction<
            ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              int,
            )
          >();

  int cgetclose() {
    return _cgetclose();
  }

  late final _cgetclosePtr = _lookup<ffi.NativeFunction<ffi.Int Function()>>(
    'cgetclose',
  );
  late final _cgetclose = _cgetclosePtr.asFunction<int Function()>();

  int cgetent(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
    ffi.Pointer<ffi.Char> arg2,
  ) {
    return _cgetent(arg0, arg1, arg2);
  }

  late final _cgetentPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<ffi.Pointer<ffi.Char>>,
        ffi.Pointer<ffi.Pointer<ffi.Char>>,
        ffi.Pointer<ffi.Char>,
      )
    >
  >('cgetent');
  late final _cgetent =
      _cgetentPtr
          .asFunction<
            int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>,
            )
          >();

  int cgetfirst(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ) {
    return _cgetfirst(arg0, arg1);
  }

  late final _cgetfirstPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<ffi.Pointer<ffi.Char>>,
        ffi.Pointer<ffi.Pointer<ffi.Char>>,
      )
    >
  >('cgetfirst');
  late final _cgetfirst =
      _cgetfirstPtr
          .asFunction<
            int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
            )
          >();

  int cgetmatch(ffi.Pointer<ffi.Char> arg0, ffi.Pointer<ffi.Char> arg1) {
    return _cgetmatch(arg0, arg1);
  }

  late final _cgetmatchPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)
    >
  >('cgetmatch');
  late final _cgetmatch =
      _cgetmatchPtr
          .asFunction<
            int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)
          >();

  int cgetnext(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ) {
    return _cgetnext(arg0, arg1);
  }

  late final _cgetnextPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<ffi.Pointer<ffi.Char>>,
        ffi.Pointer<ffi.Pointer<ffi.Char>>,
      )
    >
  >('cgetnext');
  late final _cgetnext =
      _cgetnextPtr
          .asFunction<
            int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
            )
          >();

  int cgetnum(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<ffi.Long> arg2,
  ) {
    return _cgetnum(arg0, arg1, arg2);
  }

  late final _cgetnumPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Long>,
      )
    >
  >('cgetnum');
  late final _cgetnum =
      _cgetnumPtr
          .asFunction<
            int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Long>,
            )
          >();

  int cgetset(ffi.Pointer<ffi.Char> arg0) {
    return _cgetset(arg0);
  }

  late final _cgetsetPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
        'cgetset',
      );
  late final _cgetset =
      _cgetsetPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int cgetstr(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg2,
  ) {
    return _cgetstr(arg0, arg1, arg2);
  }

  late final _cgetstrPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Pointer<ffi.Char>>,
      )
    >
  >('cgetstr');
  late final _cgetstr =
      _cgetstrPtr
          .asFunction<
            int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
            )
          >();

  int cgetustr(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg2,
  ) {
    return _cgetustr(arg0, arg1, arg2);
  }

  late final _cgetustrPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Pointer<ffi.Char>>,
      )
    >
  >('cgetustr');
  late final _cgetustr =
      _cgetustrPtr
          .asFunction<
            int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
            )
          >();

  int daemon(int arg0, int arg1) {
    return _daemon(arg0, arg1);
  }

  late final _daemonPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>('daemon');
  late final _daemon = _daemonPtr.asFunction<int Function(int, int)>();

  ffi.Pointer<ffi.Char> devname(int arg0, int arg1) {
    return _devname(arg0, arg1);
  }

  late final _devnamePtr = _lookup<
    ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(dev_t, mode_t)>
  >('devname');
  late final _devname =
      _devnamePtr.asFunction<ffi.Pointer<ffi.Char> Function(int, int)>();

  ffi.Pointer<ffi.Char> devname_r(
    int arg0,
    int arg1,
    ffi.Pointer<ffi.Char> buf,
    int len,
  ) {
    return _devname_r(arg0, arg1, buf, len);
  }

  late final _devname_rPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<ffi.Char> Function(
        dev_t,
        mode_t,
        ffi.Pointer<ffi.Char>,
        ffi.Int,
      )
    >
  >('devname_r');
  late final _devname_r =
      _devname_rPtr
          .asFunction<
            ffi.Pointer<ffi.Char> Function(int, int, ffi.Pointer<ffi.Char>, int)
          >();

  ffi.Pointer<ffi.Char> getbsize(
    ffi.Pointer<ffi.Int> arg0,
    ffi.Pointer<ffi.Long> arg1,
  ) {
    return _getbsize(arg0, arg1);
  }

  late final _getbsizePtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<ffi.Char> Function(
        ffi.Pointer<ffi.Int>,
        ffi.Pointer<ffi.Long>,
      )
    >
  >('getbsize');
  late final _getbsize =
      _getbsizePtr
          .asFunction<
            ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Long>,
            )
          >();

  int getloadavg(ffi.Pointer<ffi.Double> arg0, int arg1) {
    return _getloadavg(arg0, arg1);
  }

  late final _getloadavgPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Double>, ffi.Int)>
  >('getloadavg');
  late final _getloadavg =
      _getloadavgPtr.asFunction<int Function(ffi.Pointer<ffi.Double>, int)>();

  ffi.Pointer<ffi.Char> getprogname() {
    return _getprogname();
  }

  late final _getprognamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
        'getprogname',
      );
  late final _getprogname =
      _getprognamePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  void setprogname(ffi.Pointer<ffi.Char> arg0) {
    return _setprogname(arg0);
  }

  late final _setprognamePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
        'setprogname',
      );
  late final _setprogname =
      _setprognamePtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  int heapsort(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)
      >
    >
    __compar,
  ) {
    return _heapsort(__base, __nel, __width, __compar);
  }

  late final _heapsortPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<ffi.Void>,
        ffi.Size,
        ffi.Size,
        ffi.Pointer<
          ffi.NativeFunction<
            ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)
          >
        >,
      )
    >
  >('heapsort');
  late final _heapsort =
      _heapsortPtr
          .asFunction<
            int Function(
              ffi.Pointer<ffi.Void>,
              int,
              int,
              ffi.Pointer<
                ffi.NativeFunction<
                  ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)
                >
              >,
            )
          >();

  int mergesort(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)
      >
    >
    __compar,
  ) {
    return _mergesort(__base, __nel, __width, __compar);
  }

  late final _mergesortPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<ffi.Void>,
        ffi.Size,
        ffi.Size,
        ffi.Pointer<
          ffi.NativeFunction<
            ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)
          >
        >,
      )
    >
  >('mergesort');
  late final _mergesort =
      _mergesortPtr
          .asFunction<
            int Function(
              ffi.Pointer<ffi.Void>,
              int,
              int,
              ffi.Pointer<
                ffi.NativeFunction<
                  ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)
                >
              >,
            )
          >();

  void psort(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)
      >
    >
    __compar,
  ) {
    return _psort(__base, __nel, __width, __compar);
  }

  late final _psortPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Size,
        ffi.Size,
        ffi.Pointer<
          ffi.NativeFunction<
            ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)
          >
        >,
      )
    >
  >('psort');
  late final _psort =
      _psortPtr
          .asFunction<
            void Function(
              ffi.Pointer<ffi.Void>,
              int,
              int,
              ffi.Pointer<
                ffi.NativeFunction<
                  ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)
                >
              >,
            )
          >();

  void psort_r(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<ffi.Void> arg3,
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Int Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
        )
      >
    >
    __compar,
  ) {
    return _psort_r(__base, __nel, __width, arg3, __compar);
  }

  late final _psort_rPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Size,
        ffi.Size,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<
          ffi.NativeFunction<
            ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
            )
          >
        >,
      )
    >
  >('psort_r');
  late final _psort_r =
      _psort_rPtr
          .asFunction<
            void Function(
              ffi.Pointer<ffi.Void>,
              int,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                ffi.NativeFunction<
                  ffi.Int Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<ffi.Void>,
                  )
                >
              >,
            )
          >();

  void qsort_r(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<ffi.Void> arg3,
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Int Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
        )
      >
    >
    __compar,
  ) {
    return _qsort_r(__base, __nel, __width, arg3, __compar);
  }

  late final _qsort_rPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Size,
        ffi.Size,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<
          ffi.NativeFunction<
            ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
            )
          >
        >,
      )
    >
  >('qsort_r');
  late final _qsort_r =
      _qsort_rPtr
          .asFunction<
            void Function(
              ffi.Pointer<ffi.Void>,
              int,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                ffi.NativeFunction<
                  ffi.Int Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<ffi.Void>,
                  )
                >
              >,
            )
          >();

  int radixsort(
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> __base,
    int __nel,
    ffi.Pointer<ffi.UnsignedChar> __table,
    int __endbyte,
  ) {
    return _radixsort(__base, __nel, __table, __endbyte);
  }

  late final _radixsortPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
        ffi.Int,
        ffi.Pointer<ffi.UnsignedChar>,
        ffi.UnsignedInt,
      )
    >
  >('radixsort');
  late final _radixsort =
      _radixsortPtr
          .asFunction<
            int Function(
              ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
              int,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
            )
          >();

  int rpmatch(ffi.Pointer<ffi.Char> arg0) {
    return _rpmatch(arg0);
  }

  late final _rpmatchPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
        'rpmatch',
      );
  late final _rpmatch =
      _rpmatchPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int sradixsort(
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> __base,
    int __nel,
    ffi.Pointer<ffi.UnsignedChar> __table,
    int __endbyte,
  ) {
    return _sradixsort(__base, __nel, __table, __endbyte);
  }

  late final _sradixsortPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
        ffi.Int,
        ffi.Pointer<ffi.UnsignedChar>,
        ffi.UnsignedInt,
      )
    >
  >('sradixsort');
  late final _sradixsort =
      _sradixsortPtr
          .asFunction<
            int Function(
              ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
              int,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
            )
          >();

  void sranddev() {
    return _sranddev();
  }

  late final _sranddevPtr = _lookup<ffi.NativeFunction<ffi.Void Function()>>(
    'sranddev',
  );
  late final _sranddev = _sranddevPtr.asFunction<void Function()>();

  void srandomdev() {
    return _srandomdev();
  }

  late final _srandomdevPtr = _lookup<ffi.NativeFunction<ffi.Void Function()>>(
    'srandomdev',
  );
  late final _srandomdev = _srandomdevPtr.asFunction<void Function()>();

  int strtonum(
    ffi.Pointer<ffi.Char> __numstr,
    int __minval,
    int __maxval,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __errstrp,
  ) {
    return _strtonum(__numstr, __minval, __maxval, __errstrp);
  }

  late final _strtonumPtr = _lookup<
    ffi.NativeFunction<
      ffi.LongLong Function(
        ffi.Pointer<ffi.Char>,
        ffi.LongLong,
        ffi.LongLong,
        ffi.Pointer<ffi.Pointer<ffi.Char>>,
      )
    >
  >('strtonum');
  late final _strtonum =
      _strtonumPtr
          .asFunction<
            int Function(
              ffi.Pointer<ffi.Char>,
              int,
              int,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
            )
          >();

  int strtoq(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoq(__str, __endptr, __base);
  }

  late final _strtoqPtr = _lookup<
    ffi.NativeFunction<
      ffi.LongLong Function(
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Pointer<ffi.Char>>,
        ffi.Int,
      )
    >
  >('strtoq');
  late final _strtoq =
      _strtoqPtr
          .asFunction<
            int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              int,
            )
          >();

  int strtouq(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtouq(__str, __endptr, __base);
  }

  late final _strtouqPtr = _lookup<
    ffi.NativeFunction<
      ffi.UnsignedLongLong Function(
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Pointer<ffi.Char>>,
        ffi.Int,
      )
    >
  >('strtouq');
  late final _strtouq =
      _strtouqPtr
          .asFunction<
            int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              int,
            )
          >();

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _suboptarg =
      _lookup<ffi.Pointer<ffi.Char>>('suboptarg');

  ffi.Pointer<ffi.Char> get suboptarg => _suboptarg.value;

  set suboptarg(ffi.Pointer<ffi.Char> value) => _suboptarg.value = value;

  /// Create a new parser.
  ffi.Pointer<TSParser> ts_parser_new() {
    return _ts_parser_new();
  }

  late final _ts_parser_newPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<TSParser> Function()>>(
        'ts_parser_new',
      );
  late final _ts_parser_new =
      _ts_parser_newPtr.asFunction<ffi.Pointer<TSParser> Function()>();

  /// Delete the parser, freeing all of the memory that it used.
  void ts_parser_delete(ffi.Pointer<TSParser> self) {
    return _ts_parser_delete(self);
  }

  late final _ts_parser_deletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSParser>)>>(
        'ts_parser_delete',
      );
  late final _ts_parser_delete =
      _ts_parser_deletePtr.asFunction<void Function(ffi.Pointer<TSParser>)>();

  /// Get the parser's current language.
  ffi.Pointer<TSLanguage> ts_parser_language(ffi.Pointer<TSParser> self) {
    return _ts_parser_language(self);
  }

  late final _ts_parser_languagePtr = _lookup<
    ffi.NativeFunction<ffi.Pointer<TSLanguage> Function(ffi.Pointer<TSParser>)>
  >('ts_parser_language');
  late final _ts_parser_language =
      _ts_parser_languagePtr
          .asFunction<
            ffi.Pointer<TSLanguage> Function(ffi.Pointer<TSParser>)
          >();

  /// Set the language that the parser should use for parsing.
  ///
  /// Returns a boolean indicating whether or not the language was successfully
  /// assigned. True means assignment succeeded. False means there was a version
  /// mismatch: the language was generated with an incompatible version of the
  /// Tree-sitter CLI. Check the language's ABI version using [`ts_language_abi_version`]
  /// and compare it to this library's [`TREE_SITTER_LANGUAGE_VERSION`] and
  /// [`TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION`] constants.
  bool ts_parser_set_language(
    ffi.Pointer<TSParser> self,
    ffi.Pointer<TSLanguage> language,
  ) {
    return _ts_parser_set_language(self, language);
  }

  late final _ts_parser_set_languagePtr = _lookup<
    ffi.NativeFunction<
      ffi.Bool Function(ffi.Pointer<TSParser>, ffi.Pointer<TSLanguage>)
    >
  >('ts_parser_set_language');
  late final _ts_parser_set_language =
      _ts_parser_set_languagePtr
          .asFunction<
            bool Function(ffi.Pointer<TSParser>, ffi.Pointer<TSLanguage>)
          >();

  /// Set the ranges of text that the parser should include when parsing.
  ///
  /// By default, the parser will always include entire documents. This function
  /// allows you to parse only a *portion* of a document but still return a syntax
  /// tree whose ranges match up with the document as a whole. You can also pass
  /// multiple disjoint ranges.
  ///
  /// The second and third parameters specify the location and length of an array
  /// of ranges. The parser does *not* take ownership of these ranges; it copies
  /// the data, so it doesn't matter how these ranges are allocated.
  ///
  /// If `count` is zero, then the entire document will be parsed. Otherwise,
  /// the given ranges must be ordered from earliest to latest in the document,
  /// and they must not overlap. That is, the following must hold for all:
  ///
  /// `i < count - 1`: `ranges[i].end_byte <= ranges[i + 1].start_byte`
  ///
  /// If this requirement is not satisfied, the operation will fail, the ranges
  /// will not be assigned, and this function will return `false`. On success,
  /// this function returns `true`
  bool ts_parser_set_included_ranges(
    ffi.Pointer<TSParser> self,
    ffi.Pointer<TSRange> ranges,
    int count,
  ) {
    return _ts_parser_set_included_ranges(self, ranges, count);
  }

  late final _ts_parser_set_included_rangesPtr = _lookup<
    ffi.NativeFunction<
      ffi.Bool Function(ffi.Pointer<TSParser>, ffi.Pointer<TSRange>, ffi.Uint32)
    >
  >('ts_parser_set_included_ranges');
  late final _ts_parser_set_included_ranges =
      _ts_parser_set_included_rangesPtr
          .asFunction<
            bool Function(ffi.Pointer<TSParser>, ffi.Pointer<TSRange>, int)
          >();

  /// Get the ranges of text that the parser will include when parsing.
  ///
  /// The returned pointer is owned by the parser. The caller should not free it
  /// or write to it. The length of the array will be written to the given
  /// `count` pointer.
  ffi.Pointer<TSRange> ts_parser_included_ranges(
    ffi.Pointer<TSParser> self,
    ffi.Pointer<ffi.Uint32> count,
  ) {
    return _ts_parser_included_ranges(self, count);
  }

  late final _ts_parser_included_rangesPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<TSRange> Function(
        ffi.Pointer<TSParser>,
        ffi.Pointer<ffi.Uint32>,
      )
    >
  >('ts_parser_included_ranges');
  late final _ts_parser_included_ranges =
      _ts_parser_included_rangesPtr
          .asFunction<
            ffi.Pointer<TSRange> Function(
              ffi.Pointer<TSParser>,
              ffi.Pointer<ffi.Uint32>,
            )
          >();

  /// Use the parser to parse some source code and create a syntax tree.
  ///
  /// If you are parsing this document for the first time, pass `NULL` for the
  /// `old_tree` parameter. Otherwise, if you have already parsed an earlier
  /// version of this document and the document has since been edited, pass the
  /// previous syntax tree so that the unchanged parts of it can be reused.
  /// This will save time and memory. For this to work correctly, you must have
  /// already edited the old syntax tree using the [`ts_tree_edit`] function in a
  /// way that exactly matches the source code changes.
  ///
  /// The [`TSInput`] parameter lets you specify how to read the text. It has the
  /// following three fields:
  /// 1. [`read`]: A function to retrieve a chunk of text at a given byte offset
  /// and (row, column) position. The function should return a pointer to the
  /// text and write its length to the [`bytes_read`] pointer. The parser does
  /// not take ownership of this buffer; it just borrows it until it has
  /// finished reading it. The function should write a zero value to the
  /// [`bytes_read`] pointer to indicate the end of the document.
  /// 2. [`payload`]: An arbitrary pointer that will be passed to each invocation
  /// of the [`read`] function.
  /// 3. [`encoding`]: An indication of how the text is encoded. Either
  /// `TSInputEncodingUTF8` or `TSInputEncodingUTF16`.
  ///
  /// This function returns a syntax tree on success, and `NULL` on failure. There
  /// are four possible reasons for failure:
  /// 1. The parser does not have a language assigned. Check for this using the
  /// [`ts_parser_language`] function.
  /// 2. Parsing was cancelled due to a timeout that was set by an earlier call to
  /// the [`ts_parser_set_timeout_micros`] function. You can resume parsing from
  /// where the parser left out by calling [`ts_parser_parse`] again with the
  /// same arguments. Or you can start parsing from scratch by first calling
  /// [`ts_parser_reset`].
  /// 3. Parsing was cancelled using a cancellation flag that was set by an
  /// earlier call to [`ts_parser_set_cancellation_flag`]. You can resume parsing
  /// from where the parser left out by calling [`ts_parser_parse`] again with
  /// the same arguments.
  /// 4. Parsing was cancelled due to the progress callback returning true. This callback
  /// is passed in [`ts_parser_parse_with_options`] inside the [`TSParseOptions`] struct.
  ///
  /// [`read`]: TSInput::read
  /// [`payload`]: TSInput::payload
  /// [`encoding`]: TSInput::encoding
  /// [`bytes_read`]: TSInput::read
  ffi.Pointer<TSTree> ts_parser_parse(
    ffi.Pointer<TSParser> self,
    ffi.Pointer<TSTree> old_tree,
    TSInput input,
  ) {
    return _ts_parser_parse(self, old_tree, input);
  }

  late final _ts_parser_parsePtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<TSTree> Function(
        ffi.Pointer<TSParser>,
        ffi.Pointer<TSTree>,
        TSInput,
      )
    >
  >('ts_parser_parse');
  late final _ts_parser_parse =
      _ts_parser_parsePtr
          .asFunction<
            ffi.Pointer<TSTree> Function(
              ffi.Pointer<TSParser>,
              ffi.Pointer<TSTree>,
              TSInput,
            )
          >();

  /// Use the parser to parse some source code and create a syntax tree, with some options.
  ///
  /// See [`ts_parser_parse`] for more details.
  ///
  /// See [`TSParseOptions`] for more details on the options.
  ffi.Pointer<TSTree> ts_parser_parse_with_options(
    ffi.Pointer<TSParser> self,
    ffi.Pointer<TSTree> old_tree,
    TSInput input,
    TSParseOptions parse_options,
  ) {
    return _ts_parser_parse_with_options(self, old_tree, input, parse_options);
  }

  late final _ts_parser_parse_with_optionsPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<TSTree> Function(
        ffi.Pointer<TSParser>,
        ffi.Pointer<TSTree>,
        TSInput,
        TSParseOptions,
      )
    >
  >('ts_parser_parse_with_options');
  late final _ts_parser_parse_with_options =
      _ts_parser_parse_with_optionsPtr
          .asFunction<
            ffi.Pointer<TSTree> Function(
              ffi.Pointer<TSParser>,
              ffi.Pointer<TSTree>,
              TSInput,
              TSParseOptions,
            )
          >();

  /// Use the parser to parse some source code stored in one contiguous buffer.
  /// The first two parameters are the same as in the [`ts_parser_parse`] function
  /// above. The second two parameters indicate the location of the buffer and its
  /// length in bytes.
  ffi.Pointer<TSTree> ts_parser_parse_string(
    ffi.Pointer<TSParser> self,
    ffi.Pointer<TSTree> old_tree,
    ffi.Pointer<ffi.Char> string,
    int length,
  ) {
    return _ts_parser_parse_string(self, old_tree, string, length);
  }

  late final _ts_parser_parse_stringPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<TSTree> Function(
        ffi.Pointer<TSParser>,
        ffi.Pointer<TSTree>,
        ffi.Pointer<ffi.Char>,
        ffi.Uint32,
      )
    >
  >('ts_parser_parse_string');
  late final _ts_parser_parse_string =
      _ts_parser_parse_stringPtr
          .asFunction<
            ffi.Pointer<TSTree> Function(
              ffi.Pointer<TSParser>,
              ffi.Pointer<TSTree>,
              ffi.Pointer<ffi.Char>,
              int,
            )
          >();

  /// Use the parser to parse some source code stored in one contiguous buffer with
  /// a given encoding. The first four parameters work the same as in the
  /// [`ts_parser_parse_string`] method above. The final parameter indicates whether
  /// the text is encoded as UTF8 or UTF16.
  ffi.Pointer<TSTree> ts_parser_parse_string_encoding(
    ffi.Pointer<TSParser> self,
    ffi.Pointer<TSTree> old_tree,
    ffi.Pointer<ffi.Char> string,
    int length,
    TSInputEncoding encoding,
  ) {
    return _ts_parser_parse_string_encoding(
      self,
      old_tree,
      string,
      length,
      encoding.value,
    );
  }

  late final _ts_parser_parse_string_encodingPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<TSTree> Function(
        ffi.Pointer<TSParser>,
        ffi.Pointer<TSTree>,
        ffi.Pointer<ffi.Char>,
        ffi.Uint32,
        ffi.UnsignedInt,
      )
    >
  >('ts_parser_parse_string_encoding');
  late final _ts_parser_parse_string_encoding =
      _ts_parser_parse_string_encodingPtr
          .asFunction<
            ffi.Pointer<TSTree> Function(
              ffi.Pointer<TSParser>,
              ffi.Pointer<TSTree>,
              ffi.Pointer<ffi.Char>,
              int,
              int,
            )
          >();

  /// Instruct the parser to start the next parse from the beginning.
  ///
  /// If the parser previously failed because of a timeout or a cancellation, then
  /// by default, it will resume where it left off on the next call to
  /// [`ts_parser_parse`] or other parsing functions. If you don't want to resume,
  /// and instead intend to use this parser to parse some other document, you must
  /// call [`ts_parser_reset`] first.
  void ts_parser_reset(ffi.Pointer<TSParser> self) {
    return _ts_parser_reset(self);
  }

  late final _ts_parser_resetPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSParser>)>>(
        'ts_parser_reset',
      );
  late final _ts_parser_reset =
      _ts_parser_resetPtr.asFunction<void Function(ffi.Pointer<TSParser>)>();

  /// @deprecated use [`ts_parser_parse_with_options`] and pass in a callback instead, this will be removed in 0.26.
  ///
  /// Set the maximum duration in microseconds that parsing should be allowed to
  /// take before halting.
  ///
  /// If parsing takes longer than this, it will halt early, returning NULL.
  /// See [`ts_parser_parse`] for more information.
  void ts_parser_set_timeout_micros(
    ffi.Pointer<TSParser> self,
    int timeout_micros,
  ) {
    return _ts_parser_set_timeout_micros(self, timeout_micros);
  }

  late final _ts_parser_set_timeout_microsPtr = _lookup<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSParser>, ffi.Uint64)>
  >('ts_parser_set_timeout_micros');
  late final _ts_parser_set_timeout_micros =
      _ts_parser_set_timeout_microsPtr
          .asFunction<void Function(ffi.Pointer<TSParser>, int)>();

  /// @deprecated use [`ts_parser_parse_with_options`] and pass in a callback instead, this will be removed in 0.26.
  ///
  /// Get the duration in microseconds that parsing is allowed to take.
  int ts_parser_timeout_micros(ffi.Pointer<TSParser> self) {
    return _ts_parser_timeout_micros(self);
  }

  late final _ts_parser_timeout_microsPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<TSParser>)>>(
        'ts_parser_timeout_micros',
      );
  late final _ts_parser_timeout_micros =
      _ts_parser_timeout_microsPtr
          .asFunction<int Function(ffi.Pointer<TSParser>)>();

  /// @deprecated use [`ts_parser_parse_with_options`] and pass in a callback instead, this will be removed in 0.26.
  ///
  /// Set the parser's current cancellation flag pointer.
  ///
  /// If a non-null pointer is assigned, then the parser will periodically read
  /// from this pointer during parsing. If it reads a non-zero value, it will
  /// halt early, returning NULL. See [`ts_parser_parse`] for more information.
  void ts_parser_set_cancellation_flag(
    ffi.Pointer<TSParser> self,
    ffi.Pointer<ffi.Size> flag,
  ) {
    return _ts_parser_set_cancellation_flag(self, flag);
  }

  late final _ts_parser_set_cancellation_flagPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<TSParser>, ffi.Pointer<ffi.Size>)
    >
  >('ts_parser_set_cancellation_flag');
  late final _ts_parser_set_cancellation_flag =
      _ts_parser_set_cancellation_flagPtr
          .asFunction<
            void Function(ffi.Pointer<TSParser>, ffi.Pointer<ffi.Size>)
          >();

  /// @deprecated use [`ts_parser_parse_with_options`] and pass in a callback instead, this will be removed in 0.26.
  ///
  /// Get the parser's current cancellation flag pointer.
  ffi.Pointer<ffi.Size> ts_parser_cancellation_flag(
    ffi.Pointer<TSParser> self,
  ) {
    return _ts_parser_cancellation_flag(self);
  }

  late final _ts_parser_cancellation_flagPtr = _lookup<
    ffi.NativeFunction<ffi.Pointer<ffi.Size> Function(ffi.Pointer<TSParser>)>
  >('ts_parser_cancellation_flag');
  late final _ts_parser_cancellation_flag =
      _ts_parser_cancellation_flagPtr
          .asFunction<ffi.Pointer<ffi.Size> Function(ffi.Pointer<TSParser>)>();

  /// Set the logger that a parser should use during parsing.
  ///
  /// The parser does not take ownership over the logger payload. If a logger was
  /// previously assigned, the caller is responsible for releasing any memory
  /// owned by the previous logger.
  void ts_parser_set_logger(ffi.Pointer<TSParser> self, TSLogger logger) {
    return _ts_parser_set_logger(self, logger);
  }

  late final _ts_parser_set_loggerPtr = _lookup<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSParser>, TSLogger)>
  >('ts_parser_set_logger');
  late final _ts_parser_set_logger =
      _ts_parser_set_loggerPtr
          .asFunction<void Function(ffi.Pointer<TSParser>, TSLogger)>();

  /// Get the parser's current logger.
  TSLogger ts_parser_logger(ffi.Pointer<TSParser> self) {
    return _ts_parser_logger(self);
  }

  late final _ts_parser_loggerPtr =
      _lookup<ffi.NativeFunction<TSLogger Function(ffi.Pointer<TSParser>)>>(
        'ts_parser_logger',
      );
  late final _ts_parser_logger =
      _ts_parser_loggerPtr
          .asFunction<TSLogger Function(ffi.Pointer<TSParser>)>();

  /// Set the file descriptor to which the parser should write debugging graphs
  /// during parsing. The graphs are formatted in the DOT language. You may want
  /// to pipe these graphs directly to a `dot(1)` process in order to generate
  /// SVG output. You can turn off this logging by passing a negative number.
  void ts_parser_print_dot_graphs(ffi.Pointer<TSParser> self, int fd) {
    return _ts_parser_print_dot_graphs(self, fd);
  }

  late final _ts_parser_print_dot_graphsPtr = _lookup<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSParser>, ffi.Int)>
  >('ts_parser_print_dot_graphs');
  late final _ts_parser_print_dot_graphs =
      _ts_parser_print_dot_graphsPtr
          .asFunction<void Function(ffi.Pointer<TSParser>, int)>();

  /// Create a shallow copy of the syntax tree. This is very fast.
  ///
  /// You need to copy a syntax tree in order to use it on more than one thread at
  /// a time, as syntax trees are not thread safe.
  ffi.Pointer<TSTree> ts_tree_copy(ffi.Pointer<TSTree> self) {
    return _ts_tree_copy(self);
  }

  late final _ts_tree_copyPtr = _lookup<
    ffi.NativeFunction<ffi.Pointer<TSTree> Function(ffi.Pointer<TSTree>)>
  >('ts_tree_copy');
  late final _ts_tree_copy =
      _ts_tree_copyPtr
          .asFunction<ffi.Pointer<TSTree> Function(ffi.Pointer<TSTree>)>();

  /// Delete the syntax tree, freeing all of the memory that it used.
  void ts_tree_delete(ffi.Pointer<TSTree> self) {
    return _ts_tree_delete(self);
  }

  late final _ts_tree_deletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSTree>)>>(
        'ts_tree_delete',
      );
  late final _ts_tree_delete =
      _ts_tree_deletePtr.asFunction<void Function(ffi.Pointer<TSTree>)>();

  /// Get the root node of the syntax tree.
  TSNode ts_tree_root_node(ffi.Pointer<TSTree> self) {
    return _ts_tree_root_node(self);
  }

  late final _ts_tree_root_nodePtr =
      _lookup<ffi.NativeFunction<TSNode Function(ffi.Pointer<TSTree>)>>(
        'ts_tree_root_node',
      );
  late final _ts_tree_root_node =
      _ts_tree_root_nodePtr.asFunction<TSNode Function(ffi.Pointer<TSTree>)>();

  /// Get the root node of the syntax tree, but with its position
  /// shifted forward by the given offset.
  TSNode ts_tree_root_node_with_offset(
    ffi.Pointer<TSTree> self,
    int offset_bytes,
    TSPoint offset_extent,
  ) {
    return _ts_tree_root_node_with_offset(self, offset_bytes, offset_extent);
  }

  late final _ts_tree_root_node_with_offsetPtr = _lookup<
    ffi.NativeFunction<
      TSNode Function(ffi.Pointer<TSTree>, ffi.Uint32, TSPoint)
    >
  >('ts_tree_root_node_with_offset');
  late final _ts_tree_root_node_with_offset =
      _ts_tree_root_node_with_offsetPtr
          .asFunction<TSNode Function(ffi.Pointer<TSTree>, int, TSPoint)>();

  /// Get the language that was used to parse the syntax tree.
  ffi.Pointer<TSLanguage> ts_tree_language(ffi.Pointer<TSTree> self) {
    return _ts_tree_language(self);
  }

  late final _ts_tree_languagePtr = _lookup<
    ffi.NativeFunction<ffi.Pointer<TSLanguage> Function(ffi.Pointer<TSTree>)>
  >('ts_tree_language');
  late final _ts_tree_language =
      _ts_tree_languagePtr
          .asFunction<ffi.Pointer<TSLanguage> Function(ffi.Pointer<TSTree>)>();

  /// Get the array of included ranges that was used to parse the syntax tree.
  ///
  /// The returned pointer must be freed by the caller.
  ffi.Pointer<TSRange> ts_tree_included_ranges(
    ffi.Pointer<TSTree> self,
    ffi.Pointer<ffi.Uint32> length,
  ) {
    return _ts_tree_included_ranges(self, length);
  }

  late final _ts_tree_included_rangesPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<TSRange> Function(
        ffi.Pointer<TSTree>,
        ffi.Pointer<ffi.Uint32>,
      )
    >
  >('ts_tree_included_ranges');
  late final _ts_tree_included_ranges =
      _ts_tree_included_rangesPtr
          .asFunction<
            ffi.Pointer<TSRange> Function(
              ffi.Pointer<TSTree>,
              ffi.Pointer<ffi.Uint32>,
            )
          >();

  /// Edit the syntax tree to keep it in sync with source code that has been
  /// edited.
  ///
  /// You must describe the edit both in terms of byte offsets and in terms of
  /// (row, column) coordinates.
  void ts_tree_edit(ffi.Pointer<TSTree> self, ffi.Pointer<TSInputEdit> edit) {
    return _ts_tree_edit(self, edit);
  }

  late final _ts_tree_editPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<TSTree>, ffi.Pointer<TSInputEdit>)
    >
  >('ts_tree_edit');
  late final _ts_tree_edit =
      _ts_tree_editPtr
          .asFunction<
            void Function(ffi.Pointer<TSTree>, ffi.Pointer<TSInputEdit>)
          >();

  /// Compare an old edited syntax tree to a new syntax tree representing the same
  /// document, returning an array of ranges whose syntactic structure has changed.
  ///
  /// For this to work correctly, the old syntax tree must have been edited such
  /// that its ranges match up to the new tree. Generally, you'll want to call
  /// this function right after calling one of the [`ts_parser_parse`] functions.
  /// You need to pass the old tree that was passed to parse, as well as the new
  /// tree that was returned from that function.
  ///
  /// The returned ranges indicate areas where the hierarchical structure of syntax
  /// nodes (from root to leaf) has changed between the old and new trees. Characters
  /// outside these ranges have identical ancestor nodes in both trees.
  ///
  /// Note that the returned ranges may be slightly larger than the exact changed areas,
  /// but Tree-sitter attempts to make them as small as possible.
  ///
  /// The returned array is allocated using `malloc` and the caller is responsible
  /// for freeing it using `free`. The length of the array will be written to the
  /// given `length` pointer.
  ffi.Pointer<TSRange> ts_tree_get_changed_ranges(
    ffi.Pointer<TSTree> old_tree,
    ffi.Pointer<TSTree> new_tree,
    ffi.Pointer<ffi.Uint32> length,
  ) {
    return _ts_tree_get_changed_ranges(old_tree, new_tree, length);
  }

  late final _ts_tree_get_changed_rangesPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<TSRange> Function(
        ffi.Pointer<TSTree>,
        ffi.Pointer<TSTree>,
        ffi.Pointer<ffi.Uint32>,
      )
    >
  >('ts_tree_get_changed_ranges');
  late final _ts_tree_get_changed_ranges =
      _ts_tree_get_changed_rangesPtr
          .asFunction<
            ffi.Pointer<TSRange> Function(
              ffi.Pointer<TSTree>,
              ffi.Pointer<TSTree>,
              ffi.Pointer<ffi.Uint32>,
            )
          >();

  /// Write a DOT graph describing the syntax tree to the given file.
  void ts_tree_print_dot_graph(ffi.Pointer<TSTree> self, int file_descriptor) {
    return _ts_tree_print_dot_graph(self, file_descriptor);
  }

  late final _ts_tree_print_dot_graphPtr = _lookup<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSTree>, ffi.Int)>
  >('ts_tree_print_dot_graph');
  late final _ts_tree_print_dot_graph =
      _ts_tree_print_dot_graphPtr
          .asFunction<void Function(ffi.Pointer<TSTree>, int)>();

  /// Get the node's type as a null-terminated string.
  ffi.Pointer<ffi.Char> ts_node_type(TSNode self) {
    return _ts_node_type(self);
  }

  late final _ts_node_typePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(TSNode)>>(
        'ts_node_type',
      );
  late final _ts_node_type =
      _ts_node_typePtr.asFunction<ffi.Pointer<ffi.Char> Function(TSNode)>();

  /// Get the node's type as a numerical id.
  int ts_node_symbol(TSNode self) {
    return _ts_node_symbol(self);
  }

  late final _ts_node_symbolPtr =
      _lookup<ffi.NativeFunction<TSSymbol Function(TSNode)>>('ts_node_symbol');
  late final _ts_node_symbol =
      _ts_node_symbolPtr.asFunction<int Function(TSNode)>();

  /// Get the node's language.
  ffi.Pointer<TSLanguage> ts_node_language(TSNode self) {
    return _ts_node_language(self);
  }

  late final _ts_node_languagePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<TSLanguage> Function(TSNode)>>(
        'ts_node_language',
      );
  late final _ts_node_language =
      _ts_node_languagePtr
          .asFunction<ffi.Pointer<TSLanguage> Function(TSNode)>();

  /// Get the node's type as it appears in the grammar ignoring aliases as a
  /// null-terminated string.
  ffi.Pointer<ffi.Char> ts_node_grammar_type(TSNode self) {
    return _ts_node_grammar_type(self);
  }

  late final _ts_node_grammar_typePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(TSNode)>>(
        'ts_node_grammar_type',
      );
  late final _ts_node_grammar_type =
      _ts_node_grammar_typePtr
          .asFunction<ffi.Pointer<ffi.Char> Function(TSNode)>();

  /// Get the node's type as a numerical id as it appears in the grammar ignoring
  /// aliases. This should be used in [`ts_language_next_state`] instead of
  /// [`ts_node_symbol`].
  int ts_node_grammar_symbol(TSNode self) {
    return _ts_node_grammar_symbol(self);
  }

  late final _ts_node_grammar_symbolPtr =
      _lookup<ffi.NativeFunction<TSSymbol Function(TSNode)>>(
        'ts_node_grammar_symbol',
      );
  late final _ts_node_grammar_symbol =
      _ts_node_grammar_symbolPtr.asFunction<int Function(TSNode)>();

  /// Get the node's start byte.
  int ts_node_start_byte(TSNode self) {
    return _ts_node_start_byte(self);
  }

  late final _ts_node_start_bytePtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(TSNode)>>(
        'ts_node_start_byte',
      );
  late final _ts_node_start_byte =
      _ts_node_start_bytePtr.asFunction<int Function(TSNode)>();

  /// Get the node's start position in terms of rows and columns.
  TSPoint ts_node_start_point(TSNode self) {
    return _ts_node_start_point(self);
  }

  late final _ts_node_start_pointPtr =
      _lookup<ffi.NativeFunction<TSPoint Function(TSNode)>>(
        'ts_node_start_point',
      );
  late final _ts_node_start_point =
      _ts_node_start_pointPtr.asFunction<TSPoint Function(TSNode)>();

  /// Get the node's end byte.
  int ts_node_end_byte(TSNode self) {
    return _ts_node_end_byte(self);
  }

  late final _ts_node_end_bytePtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(TSNode)>>(
        'ts_node_end_byte',
      );
  late final _ts_node_end_byte =
      _ts_node_end_bytePtr.asFunction<int Function(TSNode)>();

  /// Get the node's end position in terms of rows and columns.
  TSPoint ts_node_end_point(TSNode self) {
    return _ts_node_end_point(self);
  }

  late final _ts_node_end_pointPtr =
      _lookup<ffi.NativeFunction<TSPoint Function(TSNode)>>(
        'ts_node_end_point',
      );
  late final _ts_node_end_point =
      _ts_node_end_pointPtr.asFunction<TSPoint Function(TSNode)>();

  /// Get an S-expression representing the node as a string.
  ///
  /// This string is allocated with `malloc` and the caller is responsible for
  /// freeing it using `free`.
  ffi.Pointer<ffi.Char> ts_node_string(TSNode self) {
    return _ts_node_string(self);
  }

  late final _ts_node_stringPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(TSNode)>>(
        'ts_node_string',
      );
  late final _ts_node_string =
      _ts_node_stringPtr.asFunction<ffi.Pointer<ffi.Char> Function(TSNode)>();

  /// Check if the node is null. Functions like [`ts_node_child`] and
  /// [`ts_node_next_sibling`] will return a null node to indicate that no such node
  /// was found.
  bool ts_node_is_null(TSNode self) {
    return _ts_node_is_null(self);
  }

  late final _ts_node_is_nullPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(TSNode)>>('ts_node_is_null');
  late final _ts_node_is_null =
      _ts_node_is_nullPtr.asFunction<bool Function(TSNode)>();

  /// Check if the node is *named*. Named nodes correspond to named rules in the
  /// grammar, whereas *anonymous* nodes correspond to string literals in the
  /// grammar.
  bool ts_node_is_named(TSNode self) {
    return _ts_node_is_named(self);
  }

  late final _ts_node_is_namedPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(TSNode)>>(
        'ts_node_is_named',
      );
  late final _ts_node_is_named =
      _ts_node_is_namedPtr.asFunction<bool Function(TSNode)>();

  /// Check if the node is *missing*. Missing nodes are inserted by the parser in
  /// order to recover from certain kinds of syntax errors.
  bool ts_node_is_missing(TSNode self) {
    return _ts_node_is_missing(self);
  }

  late final _ts_node_is_missingPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(TSNode)>>(
        'ts_node_is_missing',
      );
  late final _ts_node_is_missing =
      _ts_node_is_missingPtr.asFunction<bool Function(TSNode)>();

  /// Check if the node is *extra*. Extra nodes represent things like comments,
  /// which are not required the grammar, but can appear anywhere.
  bool ts_node_is_extra(TSNode self) {
    return _ts_node_is_extra(self);
  }

  late final _ts_node_is_extraPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(TSNode)>>(
        'ts_node_is_extra',
      );
  late final _ts_node_is_extra =
      _ts_node_is_extraPtr.asFunction<bool Function(TSNode)>();

  /// Check if a syntax node has been edited.
  bool ts_node_has_changes(TSNode self) {
    return _ts_node_has_changes(self);
  }

  late final _ts_node_has_changesPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(TSNode)>>(
        'ts_node_has_changes',
      );
  late final _ts_node_has_changes =
      _ts_node_has_changesPtr.asFunction<bool Function(TSNode)>();

  /// Check if the node is a syntax error or contains any syntax errors.
  bool ts_node_has_error(TSNode self) {
    return _ts_node_has_error(self);
  }

  late final _ts_node_has_errorPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(TSNode)>>(
        'ts_node_has_error',
      );
  late final _ts_node_has_error =
      _ts_node_has_errorPtr.asFunction<bool Function(TSNode)>();

  /// Check if the node is a syntax error.
  bool ts_node_is_error(TSNode self) {
    return _ts_node_is_error(self);
  }

  late final _ts_node_is_errorPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(TSNode)>>(
        'ts_node_is_error',
      );
  late final _ts_node_is_error =
      _ts_node_is_errorPtr.asFunction<bool Function(TSNode)>();

  /// Get this node's parse state.
  int ts_node_parse_state(TSNode self) {
    return _ts_node_parse_state(self);
  }

  late final _ts_node_parse_statePtr =
      _lookup<ffi.NativeFunction<TSStateId Function(TSNode)>>(
        'ts_node_parse_state',
      );
  late final _ts_node_parse_state =
      _ts_node_parse_statePtr.asFunction<int Function(TSNode)>();

  /// Get the parse state after this node.
  int ts_node_next_parse_state(TSNode self) {
    return _ts_node_next_parse_state(self);
  }

  late final _ts_node_next_parse_statePtr =
      _lookup<ffi.NativeFunction<TSStateId Function(TSNode)>>(
        'ts_node_next_parse_state',
      );
  late final _ts_node_next_parse_state =
      _ts_node_next_parse_statePtr.asFunction<int Function(TSNode)>();

  /// Get the node's immediate parent.
  /// Prefer [`ts_node_child_with_descendant`] for
  /// iterating over the node's ancestors.
  TSNode ts_node_parent(TSNode self) {
    return _ts_node_parent(self);
  }

  late final _ts_node_parentPtr =
      _lookup<ffi.NativeFunction<TSNode Function(TSNode)>>('ts_node_parent');
  late final _ts_node_parent =
      _ts_node_parentPtr.asFunction<TSNode Function(TSNode)>();

  /// Get the node that contains `descendant`.
  ///
  /// Note that this can return `descendant` itself.
  TSNode ts_node_child_with_descendant(TSNode self, TSNode descendant) {
    return _ts_node_child_with_descendant(self, descendant);
  }

  late final _ts_node_child_with_descendantPtr =
      _lookup<ffi.NativeFunction<TSNode Function(TSNode, TSNode)>>(
        'ts_node_child_with_descendant',
      );
  late final _ts_node_child_with_descendant =
      _ts_node_child_with_descendantPtr
          .asFunction<TSNode Function(TSNode, TSNode)>();

  /// Get the node's child at the given index, where zero represents the first
  /// child.
  TSNode ts_node_child(TSNode self, int child_index) {
    return _ts_node_child(self, child_index);
  }

  late final _ts_node_childPtr =
      _lookup<ffi.NativeFunction<TSNode Function(TSNode, ffi.Uint32)>>(
        'ts_node_child',
      );
  late final _ts_node_child =
      _ts_node_childPtr.asFunction<TSNode Function(TSNode, int)>();

  /// Get the field name for node's child at the given index, where zero represents
  /// the first child. Returns NULL, if no field is found.
  ffi.Pointer<ffi.Char> ts_node_field_name_for_child(
    TSNode self,
    int child_index,
  ) {
    return _ts_node_field_name_for_child(self, child_index);
  }

  late final _ts_node_field_name_for_childPtr = _lookup<
    ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(TSNode, ffi.Uint32)>
  >('ts_node_field_name_for_child');
  late final _ts_node_field_name_for_child =
      _ts_node_field_name_for_childPtr
          .asFunction<ffi.Pointer<ffi.Char> Function(TSNode, int)>();

  /// Get the field name for node's named child at the given index, where zero
  /// represents the first named child. Returns NULL, if no field is found.
  ffi.Pointer<ffi.Char> ts_node_field_name_for_named_child(
    TSNode self,
    int named_child_index,
  ) {
    return _ts_node_field_name_for_named_child(self, named_child_index);
  }

  late final _ts_node_field_name_for_named_childPtr = _lookup<
    ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(TSNode, ffi.Uint32)>
  >('ts_node_field_name_for_named_child');
  late final _ts_node_field_name_for_named_child =
      _ts_node_field_name_for_named_childPtr
          .asFunction<ffi.Pointer<ffi.Char> Function(TSNode, int)>();

  /// Get the node's number of children.
  int ts_node_child_count(TSNode self) {
    return _ts_node_child_count(self);
  }

  late final _ts_node_child_countPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(TSNode)>>(
        'ts_node_child_count',
      );
  late final _ts_node_child_count =
      _ts_node_child_countPtr.asFunction<int Function(TSNode)>();

  /// Get the node's *named* child at the given index.
  ///
  /// See also [`ts_node_is_named`].
  TSNode ts_node_named_child(TSNode self, int child_index) {
    return _ts_node_named_child(self, child_index);
  }

  late final _ts_node_named_childPtr =
      _lookup<ffi.NativeFunction<TSNode Function(TSNode, ffi.Uint32)>>(
        'ts_node_named_child',
      );
  late final _ts_node_named_child =
      _ts_node_named_childPtr.asFunction<TSNode Function(TSNode, int)>();

  /// Get the node's number of *named* children.
  ///
  /// See also [`ts_node_is_named`].
  int ts_node_named_child_count(TSNode self) {
    return _ts_node_named_child_count(self);
  }

  late final _ts_node_named_child_countPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(TSNode)>>(
        'ts_node_named_child_count',
      );
  late final _ts_node_named_child_count =
      _ts_node_named_child_countPtr.asFunction<int Function(TSNode)>();

  /// Get the node's child with the given field name.
  TSNode ts_node_child_by_field_name(
    TSNode self,
    ffi.Pointer<ffi.Char> name,
    int name_length,
  ) {
    return _ts_node_child_by_field_name(self, name, name_length);
  }

  late final _ts_node_child_by_field_namePtr = _lookup<
    ffi.NativeFunction<
      TSNode Function(TSNode, ffi.Pointer<ffi.Char>, ffi.Uint32)
    >
  >('ts_node_child_by_field_name');
  late final _ts_node_child_by_field_name =
      _ts_node_child_by_field_namePtr
          .asFunction<TSNode Function(TSNode, ffi.Pointer<ffi.Char>, int)>();

  /// Get the node's child with the given numerical field id.
  ///
  /// You can convert a field name to an id using the
  /// [`ts_language_field_id_for_name`] function.
  TSNode ts_node_child_by_field_id(TSNode self, int field_id) {
    return _ts_node_child_by_field_id(self, field_id);
  }

  late final _ts_node_child_by_field_idPtr =
      _lookup<ffi.NativeFunction<TSNode Function(TSNode, TSFieldId)>>(
        'ts_node_child_by_field_id',
      );
  late final _ts_node_child_by_field_id =
      _ts_node_child_by_field_idPtr.asFunction<TSNode Function(TSNode, int)>();

  /// Get the node's next / previous sibling.
  TSNode ts_node_next_sibling(TSNode self) {
    return _ts_node_next_sibling(self);
  }

  late final _ts_node_next_siblingPtr =
      _lookup<ffi.NativeFunction<TSNode Function(TSNode)>>(
        'ts_node_next_sibling',
      );
  late final _ts_node_next_sibling =
      _ts_node_next_siblingPtr.asFunction<TSNode Function(TSNode)>();

  TSNode ts_node_prev_sibling(TSNode self) {
    return _ts_node_prev_sibling(self);
  }

  late final _ts_node_prev_siblingPtr =
      _lookup<ffi.NativeFunction<TSNode Function(TSNode)>>(
        'ts_node_prev_sibling',
      );
  late final _ts_node_prev_sibling =
      _ts_node_prev_siblingPtr.asFunction<TSNode Function(TSNode)>();

  /// Get the node's next / previous *named* sibling.
  TSNode ts_node_next_named_sibling(TSNode self) {
    return _ts_node_next_named_sibling(self);
  }

  late final _ts_node_next_named_siblingPtr =
      _lookup<ffi.NativeFunction<TSNode Function(TSNode)>>(
        'ts_node_next_named_sibling',
      );
  late final _ts_node_next_named_sibling =
      _ts_node_next_named_siblingPtr.asFunction<TSNode Function(TSNode)>();

  TSNode ts_node_prev_named_sibling(TSNode self) {
    return _ts_node_prev_named_sibling(self);
  }

  late final _ts_node_prev_named_siblingPtr =
      _lookup<ffi.NativeFunction<TSNode Function(TSNode)>>(
        'ts_node_prev_named_sibling',
      );
  late final _ts_node_prev_named_sibling =
      _ts_node_prev_named_siblingPtr.asFunction<TSNode Function(TSNode)>();

  /// Get the node's first child that contains or starts after the given byte offset.
  TSNode ts_node_first_child_for_byte(TSNode self, int byte) {
    return _ts_node_first_child_for_byte(self, byte);
  }

  late final _ts_node_first_child_for_bytePtr =
      _lookup<ffi.NativeFunction<TSNode Function(TSNode, ffi.Uint32)>>(
        'ts_node_first_child_for_byte',
      );
  late final _ts_node_first_child_for_byte =
      _ts_node_first_child_for_bytePtr
          .asFunction<TSNode Function(TSNode, int)>();

  /// Get the node's first named child that contains or starts after the given byte offset.
  TSNode ts_node_first_named_child_for_byte(TSNode self, int byte) {
    return _ts_node_first_named_child_for_byte(self, byte);
  }

  late final _ts_node_first_named_child_for_bytePtr =
      _lookup<ffi.NativeFunction<TSNode Function(TSNode, ffi.Uint32)>>(
        'ts_node_first_named_child_for_byte',
      );
  late final _ts_node_first_named_child_for_byte =
      _ts_node_first_named_child_for_bytePtr
          .asFunction<TSNode Function(TSNode, int)>();

  /// Get the node's number of descendants, including one for the node itself.
  int ts_node_descendant_count(TSNode self) {
    return _ts_node_descendant_count(self);
  }

  late final _ts_node_descendant_countPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(TSNode)>>(
        'ts_node_descendant_count',
      );
  late final _ts_node_descendant_count =
      _ts_node_descendant_countPtr.asFunction<int Function(TSNode)>();

  /// Get the smallest node within this node that spans the given range of bytes
  /// or (row, column) positions.
  TSNode ts_node_descendant_for_byte_range(TSNode self, int start, int end) {
    return _ts_node_descendant_for_byte_range(self, start, end);
  }

  late final _ts_node_descendant_for_byte_rangePtr = _lookup<
    ffi.NativeFunction<TSNode Function(TSNode, ffi.Uint32, ffi.Uint32)>
  >('ts_node_descendant_for_byte_range');
  late final _ts_node_descendant_for_byte_range =
      _ts_node_descendant_for_byte_rangePtr
          .asFunction<TSNode Function(TSNode, int, int)>();

  TSNode ts_node_descendant_for_point_range(
    TSNode self,
    TSPoint start,
    TSPoint end,
  ) {
    return _ts_node_descendant_for_point_range(self, start, end);
  }

  late final _ts_node_descendant_for_point_rangePtr =
      _lookup<ffi.NativeFunction<TSNode Function(TSNode, TSPoint, TSPoint)>>(
        'ts_node_descendant_for_point_range',
      );
  late final _ts_node_descendant_for_point_range =
      _ts_node_descendant_for_point_rangePtr
          .asFunction<TSNode Function(TSNode, TSPoint, TSPoint)>();

  /// Get the smallest named node within this node that spans the given range of
  /// bytes or (row, column) positions.
  TSNode ts_node_named_descendant_for_byte_range(
    TSNode self,
    int start,
    int end,
  ) {
    return _ts_node_named_descendant_for_byte_range(self, start, end);
  }

  late final _ts_node_named_descendant_for_byte_rangePtr = _lookup<
    ffi.NativeFunction<TSNode Function(TSNode, ffi.Uint32, ffi.Uint32)>
  >('ts_node_named_descendant_for_byte_range');
  late final _ts_node_named_descendant_for_byte_range =
      _ts_node_named_descendant_for_byte_rangePtr
          .asFunction<TSNode Function(TSNode, int, int)>();

  TSNode ts_node_named_descendant_for_point_range(
    TSNode self,
    TSPoint start,
    TSPoint end,
  ) {
    return _ts_node_named_descendant_for_point_range(self, start, end);
  }

  late final _ts_node_named_descendant_for_point_rangePtr =
      _lookup<ffi.NativeFunction<TSNode Function(TSNode, TSPoint, TSPoint)>>(
        'ts_node_named_descendant_for_point_range',
      );
  late final _ts_node_named_descendant_for_point_range =
      _ts_node_named_descendant_for_point_rangePtr
          .asFunction<TSNode Function(TSNode, TSPoint, TSPoint)>();

  /// Edit the node to keep it in-sync with source code that has been edited.
  ///
  /// This function is only rarely needed. When you edit a syntax tree with the
  /// [`ts_tree_edit`] function, all of the nodes that you retrieve from the tree
  /// afterward will already reflect the edit. You only need to use [`ts_node_edit`]
  /// when you have a [`TSNode`] instance that you want to keep and continue to use
  /// after an edit.
  void ts_node_edit(ffi.Pointer<TSNode> self, ffi.Pointer<TSInputEdit> edit) {
    return _ts_node_edit(self, edit);
  }

  late final _ts_node_editPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<TSNode>, ffi.Pointer<TSInputEdit>)
    >
  >('ts_node_edit');
  late final _ts_node_edit =
      _ts_node_editPtr
          .asFunction<
            void Function(ffi.Pointer<TSNode>, ffi.Pointer<TSInputEdit>)
          >();

  /// Check if two nodes are identical.
  bool ts_node_eq(TSNode self, TSNode other) {
    return _ts_node_eq(self, other);
  }

  late final _ts_node_eqPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(TSNode, TSNode)>>(
        'ts_node_eq',
      );
  late final _ts_node_eq =
      _ts_node_eqPtr.asFunction<bool Function(TSNode, TSNode)>();

  /// Create a new tree cursor starting from the given node.
  ///
  /// A tree cursor allows you to walk a syntax tree more efficiently than is
  /// possible using the [`TSNode`] functions. It is a mutable object that is always
  /// on a certain syntax node, and can be moved imperatively to different nodes.
  ///
  /// Note that the given node is considered the root of the cursor,
  /// and the cursor cannot walk outside this node.
  TSTreeCursor ts_tree_cursor_new(TSNode node) {
    return _ts_tree_cursor_new(node);
  }

  late final _ts_tree_cursor_newPtr =
      _lookup<ffi.NativeFunction<TSTreeCursor Function(TSNode)>>(
        'ts_tree_cursor_new',
      );
  late final _ts_tree_cursor_new =
      _ts_tree_cursor_newPtr.asFunction<TSTreeCursor Function(TSNode)>();

  /// Delete a tree cursor, freeing all of the memory that it used.
  void ts_tree_cursor_delete(ffi.Pointer<TSTreeCursor> self) {
    return _ts_tree_cursor_delete(self);
  }

  late final _ts_tree_cursor_deletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSTreeCursor>)>>(
        'ts_tree_cursor_delete',
      );
  late final _ts_tree_cursor_delete =
      _ts_tree_cursor_deletePtr
          .asFunction<void Function(ffi.Pointer<TSTreeCursor>)>();

  /// Re-initialize a tree cursor to start at the original node that the cursor was
  /// constructed with.
  void ts_tree_cursor_reset(ffi.Pointer<TSTreeCursor> self, TSNode node) {
    return _ts_tree_cursor_reset(self, node);
  }

  late final _ts_tree_cursor_resetPtr = _lookup<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSTreeCursor>, TSNode)>
  >('ts_tree_cursor_reset');
  late final _ts_tree_cursor_reset =
      _ts_tree_cursor_resetPtr
          .asFunction<void Function(ffi.Pointer<TSTreeCursor>, TSNode)>();

  /// Re-initialize a tree cursor to the same position as another cursor.
  ///
  /// Unlike [`ts_tree_cursor_reset`], this will not lose parent information and
  /// allows reusing already created cursors.
  void ts_tree_cursor_reset_to(
    ffi.Pointer<TSTreeCursor> dst,
    ffi.Pointer<TSTreeCursor> src,
  ) {
    return _ts_tree_cursor_reset_to(dst, src);
  }

  late final _ts_tree_cursor_reset_toPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<TSTreeCursor>, ffi.Pointer<TSTreeCursor>)
    >
  >('ts_tree_cursor_reset_to');
  late final _ts_tree_cursor_reset_to =
      _ts_tree_cursor_reset_toPtr
          .asFunction<
            void Function(ffi.Pointer<TSTreeCursor>, ffi.Pointer<TSTreeCursor>)
          >();

  /// Get the tree cursor's current node.
  TSNode ts_tree_cursor_current_node(ffi.Pointer<TSTreeCursor> self) {
    return _ts_tree_cursor_current_node(self);
  }

  late final _ts_tree_cursor_current_nodePtr =
      _lookup<ffi.NativeFunction<TSNode Function(ffi.Pointer<TSTreeCursor>)>>(
        'ts_tree_cursor_current_node',
      );
  late final _ts_tree_cursor_current_node =
      _ts_tree_cursor_current_nodePtr
          .asFunction<TSNode Function(ffi.Pointer<TSTreeCursor>)>();

  /// Get the field name of the tree cursor's current node.
  ///
  /// This returns `NULL` if the current node doesn't have a field.
  /// See also [`ts_node_child_by_field_name`].
  ffi.Pointer<ffi.Char> ts_tree_cursor_current_field_name(
    ffi.Pointer<TSTreeCursor> self,
  ) {
    return _ts_tree_cursor_current_field_name(self);
  }

  late final _ts_tree_cursor_current_field_namePtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<TSTreeCursor>)
    >
  >('ts_tree_cursor_current_field_name');
  late final _ts_tree_cursor_current_field_name =
      _ts_tree_cursor_current_field_namePtr
          .asFunction<
            ffi.Pointer<ffi.Char> Function(ffi.Pointer<TSTreeCursor>)
          >();

  /// Get the field id of the tree cursor's current node.
  ///
  /// This returns zero if the current node doesn't have a field.
  /// See also [`ts_node_child_by_field_id`], [`ts_language_field_id_for_name`].
  int ts_tree_cursor_current_field_id(ffi.Pointer<TSTreeCursor> self) {
    return _ts_tree_cursor_current_field_id(self);
  }

  late final _ts_tree_cursor_current_field_idPtr = _lookup<
    ffi.NativeFunction<TSFieldId Function(ffi.Pointer<TSTreeCursor>)>
  >('ts_tree_cursor_current_field_id');
  late final _ts_tree_cursor_current_field_id =
      _ts_tree_cursor_current_field_idPtr
          .asFunction<int Function(ffi.Pointer<TSTreeCursor>)>();

  /// Move the cursor to the parent of its current node.
  ///
  /// This returns `true` if the cursor successfully moved, and returns `false`
  /// if there was no parent node (the cursor was already on the root node).
  ///
  /// Note that the node the cursor was constructed with is considered the root
  /// of the cursor, and the cursor cannot walk outside this node.
  bool ts_tree_cursor_goto_parent(ffi.Pointer<TSTreeCursor> self) {
    return _ts_tree_cursor_goto_parent(self);
  }

  late final _ts_tree_cursor_goto_parentPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TSTreeCursor>)>>(
        'ts_tree_cursor_goto_parent',
      );
  late final _ts_tree_cursor_goto_parent =
      _ts_tree_cursor_goto_parentPtr
          .asFunction<bool Function(ffi.Pointer<TSTreeCursor>)>();

  /// Move the cursor to the next sibling of its current node.
  ///
  /// This returns `true` if the cursor successfully moved, and returns `false`
  /// if there was no next sibling node.
  ///
  /// Note that the node the cursor was constructed with is considered the root
  /// of the cursor, and the cursor cannot walk outside this node.
  bool ts_tree_cursor_goto_next_sibling(ffi.Pointer<TSTreeCursor> self) {
    return _ts_tree_cursor_goto_next_sibling(self);
  }

  late final _ts_tree_cursor_goto_next_siblingPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TSTreeCursor>)>>(
        'ts_tree_cursor_goto_next_sibling',
      );
  late final _ts_tree_cursor_goto_next_sibling =
      _ts_tree_cursor_goto_next_siblingPtr
          .asFunction<bool Function(ffi.Pointer<TSTreeCursor>)>();

  /// Move the cursor to the previous sibling of its current node.
  ///
  /// This returns `true` if the cursor successfully moved, and returns `false` if
  /// there was no previous sibling node.
  ///
  /// Note, that this function may be slower than
  /// [`ts_tree_cursor_goto_next_sibling`] due to how node positions are stored. In
  /// the worst case, this will need to iterate through all the children up to the
  /// previous sibling node to recalculate its position. Also note that the node the cursor
  /// was constructed with is considered the root of the cursor, and the cursor cannot
  /// walk outside this node.
  bool ts_tree_cursor_goto_previous_sibling(ffi.Pointer<TSTreeCursor> self) {
    return _ts_tree_cursor_goto_previous_sibling(self);
  }

  late final _ts_tree_cursor_goto_previous_siblingPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TSTreeCursor>)>>(
        'ts_tree_cursor_goto_previous_sibling',
      );
  late final _ts_tree_cursor_goto_previous_sibling =
      _ts_tree_cursor_goto_previous_siblingPtr
          .asFunction<bool Function(ffi.Pointer<TSTreeCursor>)>();

  /// Move the cursor to the first child of its current node.
  ///
  /// This returns `true` if the cursor successfully moved, and returns `false`
  /// if there were no children.
  bool ts_tree_cursor_goto_first_child(ffi.Pointer<TSTreeCursor> self) {
    return _ts_tree_cursor_goto_first_child(self);
  }

  late final _ts_tree_cursor_goto_first_childPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TSTreeCursor>)>>(
        'ts_tree_cursor_goto_first_child',
      );
  late final _ts_tree_cursor_goto_first_child =
      _ts_tree_cursor_goto_first_childPtr
          .asFunction<bool Function(ffi.Pointer<TSTreeCursor>)>();

  /// Move the cursor to the last child of its current node.
  ///
  /// This returns `true` if the cursor successfully moved, and returns `false` if
  /// there were no children.
  ///
  /// Note that this function may be slower than [`ts_tree_cursor_goto_first_child`]
  /// because it needs to iterate through all the children to compute the child's
  /// position.
  bool ts_tree_cursor_goto_last_child(ffi.Pointer<TSTreeCursor> self) {
    return _ts_tree_cursor_goto_last_child(self);
  }

  late final _ts_tree_cursor_goto_last_childPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TSTreeCursor>)>>(
        'ts_tree_cursor_goto_last_child',
      );
  late final _ts_tree_cursor_goto_last_child =
      _ts_tree_cursor_goto_last_childPtr
          .asFunction<bool Function(ffi.Pointer<TSTreeCursor>)>();

  /// Move the cursor to the node that is the nth descendant of
  /// the original node that the cursor was constructed with, where
  /// zero represents the original node itself.
  void ts_tree_cursor_goto_descendant(
    ffi.Pointer<TSTreeCursor> self,
    int goal_descendant_index,
  ) {
    return _ts_tree_cursor_goto_descendant(self, goal_descendant_index);
  }

  late final _ts_tree_cursor_goto_descendantPtr = _lookup<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSTreeCursor>, ffi.Uint32)>
  >('ts_tree_cursor_goto_descendant');
  late final _ts_tree_cursor_goto_descendant =
      _ts_tree_cursor_goto_descendantPtr
          .asFunction<void Function(ffi.Pointer<TSTreeCursor>, int)>();

  /// Get the index of the cursor's current node out of all of the
  /// descendants of the original node that the cursor was constructed with.
  int ts_tree_cursor_current_descendant_index(ffi.Pointer<TSTreeCursor> self) {
    return _ts_tree_cursor_current_descendant_index(self);
  }

  late final _ts_tree_cursor_current_descendant_indexPtr = _lookup<
    ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<TSTreeCursor>)>
  >('ts_tree_cursor_current_descendant_index');
  late final _ts_tree_cursor_current_descendant_index =
      _ts_tree_cursor_current_descendant_indexPtr
          .asFunction<int Function(ffi.Pointer<TSTreeCursor>)>();

  /// Get the depth of the cursor's current node relative to the original
  /// node that the cursor was constructed with.
  int ts_tree_cursor_current_depth(ffi.Pointer<TSTreeCursor> self) {
    return _ts_tree_cursor_current_depth(self);
  }

  late final _ts_tree_cursor_current_depthPtr = _lookup<
    ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<TSTreeCursor>)>
  >('ts_tree_cursor_current_depth');
  late final _ts_tree_cursor_current_depth =
      _ts_tree_cursor_current_depthPtr
          .asFunction<int Function(ffi.Pointer<TSTreeCursor>)>();

  /// Move the cursor to the first child of its current node that contains or starts after
  /// the given byte offset or point.
  ///
  /// This returns the index of the child node if one was found, and returns -1
  /// if no such child was found.
  int ts_tree_cursor_goto_first_child_for_byte(
    ffi.Pointer<TSTreeCursor> self,
    int goal_byte,
  ) {
    return _ts_tree_cursor_goto_first_child_for_byte(self, goal_byte);
  }

  late final _ts_tree_cursor_goto_first_child_for_bytePtr = _lookup<
    ffi.NativeFunction<
      ffi.Int64 Function(ffi.Pointer<TSTreeCursor>, ffi.Uint32)
    >
  >('ts_tree_cursor_goto_first_child_for_byte');
  late final _ts_tree_cursor_goto_first_child_for_byte =
      _ts_tree_cursor_goto_first_child_for_bytePtr
          .asFunction<int Function(ffi.Pointer<TSTreeCursor>, int)>();

  int ts_tree_cursor_goto_first_child_for_point(
    ffi.Pointer<TSTreeCursor> self,
    TSPoint goal_point,
  ) {
    return _ts_tree_cursor_goto_first_child_for_point(self, goal_point);
  }

  late final _ts_tree_cursor_goto_first_child_for_pointPtr = _lookup<
    ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<TSTreeCursor>, TSPoint)>
  >('ts_tree_cursor_goto_first_child_for_point');
  late final _ts_tree_cursor_goto_first_child_for_point =
      _ts_tree_cursor_goto_first_child_for_pointPtr
          .asFunction<int Function(ffi.Pointer<TSTreeCursor>, TSPoint)>();

  TSTreeCursor ts_tree_cursor_copy(ffi.Pointer<TSTreeCursor> cursor) {
    return _ts_tree_cursor_copy(cursor);
  }

  late final _ts_tree_cursor_copyPtr = _lookup<
    ffi.NativeFunction<TSTreeCursor Function(ffi.Pointer<TSTreeCursor>)>
  >('ts_tree_cursor_copy');
  late final _ts_tree_cursor_copy =
      _ts_tree_cursor_copyPtr
          .asFunction<TSTreeCursor Function(ffi.Pointer<TSTreeCursor>)>();

  /// Create a new query from a string containing one or more S-expression
  /// patterns. The query is associated with a particular language, and can
  /// only be run on syntax nodes parsed with that language.
  ///
  /// If all of the given patterns are valid, this returns a [`TSQuery`].
  /// If a pattern is invalid, this returns `NULL`, and provides two pieces
  /// of information about the problem:
  /// 1. The byte offset of the error is written to the `error_offset` parameter.
  /// 2. The type of error is written to the `error_type` parameter.
  ffi.Pointer<TSQuery> ts_query_new(
    ffi.Pointer<TSLanguage> language,
    ffi.Pointer<ffi.Char> source,
    int source_len,
    ffi.Pointer<ffi.Uint32> error_offset,
    ffi.Pointer<ffi.UnsignedInt> error_type,
  ) {
    return _ts_query_new(
      language,
      source,
      source_len,
      error_offset,
      error_type,
    );
  }

  late final _ts_query_newPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<TSQuery> Function(
        ffi.Pointer<TSLanguage>,
        ffi.Pointer<ffi.Char>,
        ffi.Uint32,
        ffi.Pointer<ffi.Uint32>,
        ffi.Pointer<ffi.UnsignedInt>,
      )
    >
  >('ts_query_new');
  late final _ts_query_new =
      _ts_query_newPtr
          .asFunction<
            ffi.Pointer<TSQuery> Function(
              ffi.Pointer<TSLanguage>,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<ffi.Uint32>,
              ffi.Pointer<ffi.UnsignedInt>,
            )
          >();

  /// Delete a query, freeing all of the memory that it used.
  void ts_query_delete(ffi.Pointer<TSQuery> self) {
    return _ts_query_delete(self);
  }

  late final _ts_query_deletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSQuery>)>>(
        'ts_query_delete',
      );
  late final _ts_query_delete =
      _ts_query_deletePtr.asFunction<void Function(ffi.Pointer<TSQuery>)>();

  /// Get the number of patterns, captures, or string literals in the query.
  int ts_query_pattern_count(ffi.Pointer<TSQuery> self) {
    return _ts_query_pattern_count(self);
  }

  late final _ts_query_pattern_countPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<TSQuery>)>>(
        'ts_query_pattern_count',
      );
  late final _ts_query_pattern_count =
      _ts_query_pattern_countPtr
          .asFunction<int Function(ffi.Pointer<TSQuery>)>();

  int ts_query_capture_count(ffi.Pointer<TSQuery> self) {
    return _ts_query_capture_count(self);
  }

  late final _ts_query_capture_countPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<TSQuery>)>>(
        'ts_query_capture_count',
      );
  late final _ts_query_capture_count =
      _ts_query_capture_countPtr
          .asFunction<int Function(ffi.Pointer<TSQuery>)>();

  int ts_query_string_count(ffi.Pointer<TSQuery> self) {
    return _ts_query_string_count(self);
  }

  late final _ts_query_string_countPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<TSQuery>)>>(
        'ts_query_string_count',
      );
  late final _ts_query_string_count =
      _ts_query_string_countPtr
          .asFunction<int Function(ffi.Pointer<TSQuery>)>();

  /// Get the byte offset where the given pattern starts in the query's source.
  ///
  /// This can be useful when combining queries by concatenating their source
  /// code strings.
  int ts_query_start_byte_for_pattern(
    ffi.Pointer<TSQuery> self,
    int pattern_index,
  ) {
    return _ts_query_start_byte_for_pattern(self, pattern_index);
  }

  late final _ts_query_start_byte_for_patternPtr = _lookup<
    ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<TSQuery>, ffi.Uint32)>
  >('ts_query_start_byte_for_pattern');
  late final _ts_query_start_byte_for_pattern =
      _ts_query_start_byte_for_patternPtr
          .asFunction<int Function(ffi.Pointer<TSQuery>, int)>();

  /// Get the byte offset where the given pattern ends in the query's source.
  ///
  /// This can be useful when combining queries by concatenating their source
  /// code strings.
  int ts_query_end_byte_for_pattern(
    ffi.Pointer<TSQuery> self,
    int pattern_index,
  ) {
    return _ts_query_end_byte_for_pattern(self, pattern_index);
  }

  late final _ts_query_end_byte_for_patternPtr = _lookup<
    ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<TSQuery>, ffi.Uint32)>
  >('ts_query_end_byte_for_pattern');
  late final _ts_query_end_byte_for_pattern =
      _ts_query_end_byte_for_patternPtr
          .asFunction<int Function(ffi.Pointer<TSQuery>, int)>();

  /// Get all of the predicates for the given pattern in the query.
  ///
  /// The predicates are represented as a single array of steps. There are three
  /// types of steps in this array, which correspond to the three legal values for
  /// the `type` field:
  /// - `TSQueryPredicateStepTypeCapture` - Steps with this type represent names
  /// of captures. Their `value_id` can be used with the
  /// [`ts_query_capture_name_for_id`] function to obtain the name of the capture.
  /// - `TSQueryPredicateStepTypeString` - Steps with this type represent literal
  /// strings. Their `value_id` can be used with the
  /// [`ts_query_string_value_for_id`] function to obtain their string value.
  /// - `TSQueryPredicateStepTypeDone` - Steps with this type are *sentinels*
  /// that represent the end of an individual predicate. If a pattern has two
  /// predicates, then there will be two steps with this `type` in the array.
  ffi.Pointer<TSQueryPredicateStep> ts_query_predicates_for_pattern(
    ffi.Pointer<TSQuery> self,
    int pattern_index,
    ffi.Pointer<ffi.Uint32> step_count,
  ) {
    return _ts_query_predicates_for_pattern(self, pattern_index, step_count);
  }

  late final _ts_query_predicates_for_patternPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<TSQueryPredicateStep> Function(
        ffi.Pointer<TSQuery>,
        ffi.Uint32,
        ffi.Pointer<ffi.Uint32>,
      )
    >
  >('ts_query_predicates_for_pattern');
  late final _ts_query_predicates_for_pattern =
      _ts_query_predicates_for_patternPtr
          .asFunction<
            ffi.Pointer<TSQueryPredicateStep> Function(
              ffi.Pointer<TSQuery>,
              int,
              ffi.Pointer<ffi.Uint32>,
            )
          >();

  bool ts_query_is_pattern_rooted(
    ffi.Pointer<TSQuery> self,
    int pattern_index,
  ) {
    return _ts_query_is_pattern_rooted(self, pattern_index);
  }

  late final _ts_query_is_pattern_rootedPtr = _lookup<
    ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TSQuery>, ffi.Uint32)>
  >('ts_query_is_pattern_rooted');
  late final _ts_query_is_pattern_rooted =
      _ts_query_is_pattern_rootedPtr
          .asFunction<bool Function(ffi.Pointer<TSQuery>, int)>();

  bool ts_query_is_pattern_non_local(
    ffi.Pointer<TSQuery> self,
    int pattern_index,
  ) {
    return _ts_query_is_pattern_non_local(self, pattern_index);
  }

  late final _ts_query_is_pattern_non_localPtr = _lookup<
    ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TSQuery>, ffi.Uint32)>
  >('ts_query_is_pattern_non_local');
  late final _ts_query_is_pattern_non_local =
      _ts_query_is_pattern_non_localPtr
          .asFunction<bool Function(ffi.Pointer<TSQuery>, int)>();

  bool ts_query_is_pattern_guaranteed_at_step(
    ffi.Pointer<TSQuery> self,
    int byte_offset,
  ) {
    return _ts_query_is_pattern_guaranteed_at_step(self, byte_offset);
  }

  late final _ts_query_is_pattern_guaranteed_at_stepPtr = _lookup<
    ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TSQuery>, ffi.Uint32)>
  >('ts_query_is_pattern_guaranteed_at_step');
  late final _ts_query_is_pattern_guaranteed_at_step =
      _ts_query_is_pattern_guaranteed_at_stepPtr
          .asFunction<bool Function(ffi.Pointer<TSQuery>, int)>();

  /// Get the name and length of one of the query's captures, or one of the
  /// query's string literals. Each capture and string is associated with a
  /// numeric id based on the order that it appeared in the query's source.
  ffi.Pointer<ffi.Char> ts_query_capture_name_for_id(
    ffi.Pointer<TSQuery> self,
    int index,
    ffi.Pointer<ffi.Uint32> length,
  ) {
    return _ts_query_capture_name_for_id(self, index, length);
  }

  late final _ts_query_capture_name_for_idPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<ffi.Char> Function(
        ffi.Pointer<TSQuery>,
        ffi.Uint32,
        ffi.Pointer<ffi.Uint32>,
      )
    >
  >('ts_query_capture_name_for_id');
  late final _ts_query_capture_name_for_id =
      _ts_query_capture_name_for_idPtr
          .asFunction<
            ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<TSQuery>,
              int,
              ffi.Pointer<ffi.Uint32>,
            )
          >();

  /// Get the quantifier of the query's captures. Each capture is * associated
  /// with a numeric id based on the order that it appeared in the query's source.
  TSQuantifier ts_query_capture_quantifier_for_id(
    ffi.Pointer<TSQuery> self,
    int pattern_index,
    int capture_index,
  ) {
    return TSQuantifier.fromValue(
      _ts_query_capture_quantifier_for_id(self, pattern_index, capture_index),
    );
  }

  late final _ts_query_capture_quantifier_for_idPtr = _lookup<
    ffi.NativeFunction<
      ffi.UnsignedInt Function(ffi.Pointer<TSQuery>, ffi.Uint32, ffi.Uint32)
    >
  >('ts_query_capture_quantifier_for_id');
  late final _ts_query_capture_quantifier_for_id =
      _ts_query_capture_quantifier_for_idPtr
          .asFunction<int Function(ffi.Pointer<TSQuery>, int, int)>();

  ffi.Pointer<ffi.Char> ts_query_string_value_for_id(
    ffi.Pointer<TSQuery> self,
    int index,
    ffi.Pointer<ffi.Uint32> length,
  ) {
    return _ts_query_string_value_for_id(self, index, length);
  }

  late final _ts_query_string_value_for_idPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<ffi.Char> Function(
        ffi.Pointer<TSQuery>,
        ffi.Uint32,
        ffi.Pointer<ffi.Uint32>,
      )
    >
  >('ts_query_string_value_for_id');
  late final _ts_query_string_value_for_id =
      _ts_query_string_value_for_idPtr
          .asFunction<
            ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<TSQuery>,
              int,
              ffi.Pointer<ffi.Uint32>,
            )
          >();

  /// Disable a certain capture within a query.
  ///
  /// This prevents the capture from being returned in matches, and also avoids
  /// any resource usage associated with recording the capture. Currently, there
  /// is no way to undo this.
  void ts_query_disable_capture(
    ffi.Pointer<TSQuery> self,
    ffi.Pointer<ffi.Char> name,
    int length,
  ) {
    return _ts_query_disable_capture(self, name, length);
  }

  late final _ts_query_disable_capturePtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<TSQuery>, ffi.Pointer<ffi.Char>, ffi.Uint32)
    >
  >('ts_query_disable_capture');
  late final _ts_query_disable_capture =
      _ts_query_disable_capturePtr
          .asFunction<
            void Function(ffi.Pointer<TSQuery>, ffi.Pointer<ffi.Char>, int)
          >();

  /// Disable a certain pattern within a query.
  ///
  /// This prevents the pattern from matching and removes most of the overhead
  /// associated with the pattern. Currently, there is no way to undo this.
  void ts_query_disable_pattern(ffi.Pointer<TSQuery> self, int pattern_index) {
    return _ts_query_disable_pattern(self, pattern_index);
  }

  late final _ts_query_disable_patternPtr = _lookup<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSQuery>, ffi.Uint32)>
  >('ts_query_disable_pattern');
  late final _ts_query_disable_pattern =
      _ts_query_disable_patternPtr
          .asFunction<void Function(ffi.Pointer<TSQuery>, int)>();

  /// Create a new cursor for executing a given query.
  ///
  /// The cursor stores the state that is needed to iteratively search
  /// for matches. To use the query cursor, first call [`ts_query_cursor_exec`]
  /// to start running a given query on a given syntax node. Then, there are
  /// two options for consuming the results of the query:
  /// 1. Repeatedly call [`ts_query_cursor_next_match`] to iterate over all of the
  /// *matches* in the order that they were found. Each match contains the
  /// index of the pattern that matched, and an array of captures. Because
  /// multiple patterns can match the same set of nodes, one match may contain
  /// captures that appear *before* some of the captures from a previous match.
  /// 2. Repeatedly call [`ts_query_cursor_next_capture`] to iterate over all of the
  /// individual *captures* in the order that they appear. This is useful if
  /// don't care about which pattern matched, and just want a single ordered
  /// sequence of captures.
  ///
  /// If you don't care about consuming all of the results, you can stop calling
  /// [`ts_query_cursor_next_match`] or [`ts_query_cursor_next_capture`] at any point.
  /// You can then start executing another query on another node by calling
  /// [`ts_query_cursor_exec`] again.
  ffi.Pointer<TSQueryCursor> ts_query_cursor_new() {
    return _ts_query_cursor_new();
  }

  late final _ts_query_cursor_newPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<TSQueryCursor> Function()>>(
        'ts_query_cursor_new',
      );
  late final _ts_query_cursor_new =
      _ts_query_cursor_newPtr
          .asFunction<ffi.Pointer<TSQueryCursor> Function()>();

  /// Delete a query cursor, freeing all of the memory that it used.
  void ts_query_cursor_delete(ffi.Pointer<TSQueryCursor> self) {
    return _ts_query_cursor_delete(self);
  }

  late final _ts_query_cursor_deletePtr = _lookup<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSQueryCursor>)>
  >('ts_query_cursor_delete');
  late final _ts_query_cursor_delete =
      _ts_query_cursor_deletePtr
          .asFunction<void Function(ffi.Pointer<TSQueryCursor>)>();

  /// Start running a given query on a given node.
  void ts_query_cursor_exec(
    ffi.Pointer<TSQueryCursor> self,
    ffi.Pointer<TSQuery> query,
    TSNode node,
  ) {
    return _ts_query_cursor_exec(self, query, node);
  }

  late final _ts_query_cursor_execPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(
        ffi.Pointer<TSQueryCursor>,
        ffi.Pointer<TSQuery>,
        TSNode,
      )
    >
  >('ts_query_cursor_exec');
  late final _ts_query_cursor_exec =
      _ts_query_cursor_execPtr
          .asFunction<
            void Function(
              ffi.Pointer<TSQueryCursor>,
              ffi.Pointer<TSQuery>,
              TSNode,
            )
          >();

  /// Start running a given query on a given node, with some options.
  void ts_query_cursor_exec_with_options(
    ffi.Pointer<TSQueryCursor> self,
    ffi.Pointer<TSQuery> query,
    TSNode node,
    ffi.Pointer<TSQueryCursorOptions> query_options,
  ) {
    return _ts_query_cursor_exec_with_options(self, query, node, query_options);
  }

  late final _ts_query_cursor_exec_with_optionsPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(
        ffi.Pointer<TSQueryCursor>,
        ffi.Pointer<TSQuery>,
        TSNode,
        ffi.Pointer<TSQueryCursorOptions>,
      )
    >
  >('ts_query_cursor_exec_with_options');
  late final _ts_query_cursor_exec_with_options =
      _ts_query_cursor_exec_with_optionsPtr
          .asFunction<
            void Function(
              ffi.Pointer<TSQueryCursor>,
              ffi.Pointer<TSQuery>,
              TSNode,
              ffi.Pointer<TSQueryCursorOptions>,
            )
          >();

  /// Manage the maximum number of in-progress matches allowed by this query
  /// cursor.
  ///
  /// Query cursors have an optional maximum capacity for storing lists of
  /// in-progress captures. If this capacity is exceeded, then the
  /// earliest-starting match will silently be dropped to make room for further
  /// matches. This maximum capacity is optional  by default, query cursors allow
  /// any number of pending matches, dynamically allocating new space for them as
  /// needed as the query is executed.
  bool ts_query_cursor_did_exceed_match_limit(ffi.Pointer<TSQueryCursor> self) {
    return _ts_query_cursor_did_exceed_match_limit(self);
  }

  late final _ts_query_cursor_did_exceed_match_limitPtr = _lookup<
    ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TSQueryCursor>)>
  >('ts_query_cursor_did_exceed_match_limit');
  late final _ts_query_cursor_did_exceed_match_limit =
      _ts_query_cursor_did_exceed_match_limitPtr
          .asFunction<bool Function(ffi.Pointer<TSQueryCursor>)>();

  int ts_query_cursor_match_limit(ffi.Pointer<TSQueryCursor> self) {
    return _ts_query_cursor_match_limit(self);
  }

  late final _ts_query_cursor_match_limitPtr = _lookup<
    ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<TSQueryCursor>)>
  >('ts_query_cursor_match_limit');
  late final _ts_query_cursor_match_limit =
      _ts_query_cursor_match_limitPtr
          .asFunction<int Function(ffi.Pointer<TSQueryCursor>)>();

  void ts_query_cursor_set_match_limit(
    ffi.Pointer<TSQueryCursor> self,
    int limit,
  ) {
    return _ts_query_cursor_set_match_limit(self, limit);
  }

  late final _ts_query_cursor_set_match_limitPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<TSQueryCursor>, ffi.Uint32)
    >
  >('ts_query_cursor_set_match_limit');
  late final _ts_query_cursor_set_match_limit =
      _ts_query_cursor_set_match_limitPtr
          .asFunction<void Function(ffi.Pointer<TSQueryCursor>, int)>();

  /// @deprecated use [`ts_query_cursor_exec_with_options`] and pass in a callback instead, this will be removed in 0.26.
  ///
  /// Set the maximum duration in microseconds that query execution should be allowed to
  /// take before halting.
  ///
  /// If query execution takes longer than this, it will halt early, returning NULL.
  /// See [`ts_query_cursor_next_match`] or [`ts_query_cursor_next_capture`] for more information.
  void ts_query_cursor_set_timeout_micros(
    ffi.Pointer<TSQueryCursor> self,
    int timeout_micros,
  ) {
    return _ts_query_cursor_set_timeout_micros(self, timeout_micros);
  }

  late final _ts_query_cursor_set_timeout_microsPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<TSQueryCursor>, ffi.Uint64)
    >
  >('ts_query_cursor_set_timeout_micros');
  late final _ts_query_cursor_set_timeout_micros =
      _ts_query_cursor_set_timeout_microsPtr
          .asFunction<void Function(ffi.Pointer<TSQueryCursor>, int)>();

  /// @deprecated use [`ts_query_cursor_exec_with_options`] and pass in a callback instead, this will be removed in 0.26.
  ///
  /// Get the duration in microseconds that query execution is allowed to take.
  ///
  /// This is set via [`ts_query_cursor_set_timeout_micros`].
  int ts_query_cursor_timeout_micros(ffi.Pointer<TSQueryCursor> self) {
    return _ts_query_cursor_timeout_micros(self);
  }

  late final _ts_query_cursor_timeout_microsPtr = _lookup<
    ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<TSQueryCursor>)>
  >('ts_query_cursor_timeout_micros');
  late final _ts_query_cursor_timeout_micros =
      _ts_query_cursor_timeout_microsPtr
          .asFunction<int Function(ffi.Pointer<TSQueryCursor>)>();

  /// Set the range of bytes in which the query will be executed.
  ///
  /// The query cursor will return matches that intersect with the given point range.
  /// This means that a match may be returned even if some of its captures fall
  /// outside the specified range, as long as at least part of the match
  /// overlaps with the range.
  ///
  /// For example, if a query pattern matches a node that spans a larger area
  /// than the specified range, but part of that node intersects with the range,
  /// the entire match will be returned.
  ///
  /// This will return `false` if the start byte is greater than the end byte, otherwise
  /// it will return `true`.
  bool ts_query_cursor_set_byte_range(
    ffi.Pointer<TSQueryCursor> self,
    int start_byte,
    int end_byte,
  ) {
    return _ts_query_cursor_set_byte_range(self, start_byte, end_byte);
  }

  late final _ts_query_cursor_set_byte_rangePtr = _lookup<
    ffi.NativeFunction<
      ffi.Bool Function(ffi.Pointer<TSQueryCursor>, ffi.Uint32, ffi.Uint32)
    >
  >('ts_query_cursor_set_byte_range');
  late final _ts_query_cursor_set_byte_range =
      _ts_query_cursor_set_byte_rangePtr
          .asFunction<bool Function(ffi.Pointer<TSQueryCursor>, int, int)>();

  /// Set the range of (row, column) positions in which the query will be executed.
  ///
  /// The query cursor will return matches that intersect with the given point range.
  /// This means that a match may be returned even if some of its captures fall
  /// outside the specified range, as long as at least part of the match
  /// overlaps with the range.
  ///
  /// For example, if a query pattern matches a node that spans a larger area
  /// than the specified range, but part of that node intersects with the range,
  /// the entire match will be returned.
  ///
  /// This will return `false` if the start point is greater than the end point, otherwise
  /// it will return `true`.
  bool ts_query_cursor_set_point_range(
    ffi.Pointer<TSQueryCursor> self,
    TSPoint start_point,
    TSPoint end_point,
  ) {
    return _ts_query_cursor_set_point_range(self, start_point, end_point);
  }

  late final _ts_query_cursor_set_point_rangePtr = _lookup<
    ffi.NativeFunction<
      ffi.Bool Function(ffi.Pointer<TSQueryCursor>, TSPoint, TSPoint)
    >
  >('ts_query_cursor_set_point_range');
  late final _ts_query_cursor_set_point_range =
      _ts_query_cursor_set_point_rangePtr
          .asFunction<
            bool Function(ffi.Pointer<TSQueryCursor>, TSPoint, TSPoint)
          >();

  /// Advance to the next match of the currently running query.
  ///
  /// If there is a match, write it to `*match` and return `true`.
  /// Otherwise, return `false`.
  bool ts_query_cursor_next_match(
    ffi.Pointer<TSQueryCursor> self,
    ffi.Pointer<TSQueryMatch> match,
  ) {
    return _ts_query_cursor_next_match(self, match);
  }

  late final _ts_query_cursor_next_matchPtr = _lookup<
    ffi.NativeFunction<
      ffi.Bool Function(ffi.Pointer<TSQueryCursor>, ffi.Pointer<TSQueryMatch>)
    >
  >('ts_query_cursor_next_match');
  late final _ts_query_cursor_next_match =
      _ts_query_cursor_next_matchPtr
          .asFunction<
            bool Function(ffi.Pointer<TSQueryCursor>, ffi.Pointer<TSQueryMatch>)
          >();

  void ts_query_cursor_remove_match(
    ffi.Pointer<TSQueryCursor> self,
    int match_id,
  ) {
    return _ts_query_cursor_remove_match(self, match_id);
  }

  late final _ts_query_cursor_remove_matchPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<TSQueryCursor>, ffi.Uint32)
    >
  >('ts_query_cursor_remove_match');
  late final _ts_query_cursor_remove_match =
      _ts_query_cursor_remove_matchPtr
          .asFunction<void Function(ffi.Pointer<TSQueryCursor>, int)>();

  /// Advance to the next capture of the currently running query.
  ///
  /// If there is a capture, write its match to `*match` and its index within
  /// the match's capture list to `*capture_index`. Otherwise, return `false`.
  bool ts_query_cursor_next_capture(
    ffi.Pointer<TSQueryCursor> self,
    ffi.Pointer<TSQueryMatch> match,
    ffi.Pointer<ffi.Uint32> capture_index,
  ) {
    return _ts_query_cursor_next_capture(self, match, capture_index);
  }

  late final _ts_query_cursor_next_capturePtr = _lookup<
    ffi.NativeFunction<
      ffi.Bool Function(
        ffi.Pointer<TSQueryCursor>,
        ffi.Pointer<TSQueryMatch>,
        ffi.Pointer<ffi.Uint32>,
      )
    >
  >('ts_query_cursor_next_capture');
  late final _ts_query_cursor_next_capture =
      _ts_query_cursor_next_capturePtr
          .asFunction<
            bool Function(
              ffi.Pointer<TSQueryCursor>,
              ffi.Pointer<TSQueryMatch>,
              ffi.Pointer<ffi.Uint32>,
            )
          >();

  /// Set the maximum start depth for a query cursor.
  ///
  /// This prevents cursors from exploring children nodes at a certain depth.
  /// Note if a pattern includes many children, then they will still be checked.
  ///
  /// The zero max start depth value can be used as a special behavior and
  /// it helps to destructure a subtree by staying on a node and using captures
  /// for interested parts. Note that the zero max start depth only limit a search
  /// depth for a pattern's root node but other nodes that are parts of the pattern
  /// may be searched at any depth what defined by the pattern structure.
  ///
  /// Set to `UINT32_MAX` to remove the maximum start depth.
  void ts_query_cursor_set_max_start_depth(
    ffi.Pointer<TSQueryCursor> self,
    int max_start_depth,
  ) {
    return _ts_query_cursor_set_max_start_depth(self, max_start_depth);
  }

  late final _ts_query_cursor_set_max_start_depthPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<TSQueryCursor>, ffi.Uint32)
    >
  >('ts_query_cursor_set_max_start_depth');
  late final _ts_query_cursor_set_max_start_depth =
      _ts_query_cursor_set_max_start_depthPtr
          .asFunction<void Function(ffi.Pointer<TSQueryCursor>, int)>();

  /// Get another reference to the given language.
  ffi.Pointer<TSLanguage> ts_language_copy(ffi.Pointer<TSLanguage> self) {
    return _ts_language_copy(self);
  }

  late final _ts_language_copyPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<TSLanguage> Function(ffi.Pointer<TSLanguage>)
    >
  >('ts_language_copy');
  late final _ts_language_copy =
      _ts_language_copyPtr
          .asFunction<
            ffi.Pointer<TSLanguage> Function(ffi.Pointer<TSLanguage>)
          >();

  /// Free any dynamically-allocated resources for this language, if
  /// this is the last reference.
  void ts_language_delete(ffi.Pointer<TSLanguage> self) {
    return _ts_language_delete(self);
  }

  late final _ts_language_deletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSLanguage>)>>(
        'ts_language_delete',
      );
  late final _ts_language_delete =
      _ts_language_deletePtr
          .asFunction<void Function(ffi.Pointer<TSLanguage>)>();

  /// Get the number of distinct node types in the language.
  int ts_language_symbol_count(ffi.Pointer<TSLanguage> self) {
    return _ts_language_symbol_count(self);
  }

  late final _ts_language_symbol_countPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<TSLanguage>)>>(
        'ts_language_symbol_count',
      );
  late final _ts_language_symbol_count =
      _ts_language_symbol_countPtr
          .asFunction<int Function(ffi.Pointer<TSLanguage>)>();

  /// Get the number of valid states in this language.
  int ts_language_state_count(ffi.Pointer<TSLanguage> self) {
    return _ts_language_state_count(self);
  }

  late final _ts_language_state_countPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<TSLanguage>)>>(
        'ts_language_state_count',
      );
  late final _ts_language_state_count =
      _ts_language_state_countPtr
          .asFunction<int Function(ffi.Pointer<TSLanguage>)>();

  /// Get the numerical id for the given node type string.
  int ts_language_symbol_for_name(
    ffi.Pointer<TSLanguage> self,
    ffi.Pointer<ffi.Char> string,
    int length,
    bool is_named,
  ) {
    return _ts_language_symbol_for_name(self, string, length, is_named);
  }

  late final _ts_language_symbol_for_namePtr = _lookup<
    ffi.NativeFunction<
      TSSymbol Function(
        ffi.Pointer<TSLanguage>,
        ffi.Pointer<ffi.Char>,
        ffi.Uint32,
        ffi.Bool,
      )
    >
  >('ts_language_symbol_for_name');
  late final _ts_language_symbol_for_name =
      _ts_language_symbol_for_namePtr
          .asFunction<
            int Function(
              ffi.Pointer<TSLanguage>,
              ffi.Pointer<ffi.Char>,
              int,
              bool,
            )
          >();

  /// Get the number of distinct field names in the language.
  int ts_language_field_count(ffi.Pointer<TSLanguage> self) {
    return _ts_language_field_count(self);
  }

  late final _ts_language_field_countPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<TSLanguage>)>>(
        'ts_language_field_count',
      );
  late final _ts_language_field_count =
      _ts_language_field_countPtr
          .asFunction<int Function(ffi.Pointer<TSLanguage>)>();

  /// Get the field name string for the given numerical id.
  ffi.Pointer<ffi.Char> ts_language_field_name_for_id(
    ffi.Pointer<TSLanguage> self,
    int id,
  ) {
    return _ts_language_field_name_for_id(self, id);
  }

  late final _ts_language_field_name_for_idPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<TSLanguage>, TSFieldId)
    >
  >('ts_language_field_name_for_id');
  late final _ts_language_field_name_for_id =
      _ts_language_field_name_for_idPtr
          .asFunction<
            ffi.Pointer<ffi.Char> Function(ffi.Pointer<TSLanguage>, int)
          >();

  /// Get the numerical id for the given field name string.
  int ts_language_field_id_for_name(
    ffi.Pointer<TSLanguage> self,
    ffi.Pointer<ffi.Char> name,
    int name_length,
  ) {
    return _ts_language_field_id_for_name(self, name, name_length);
  }

  late final _ts_language_field_id_for_namePtr = _lookup<
    ffi.NativeFunction<
      TSFieldId Function(
        ffi.Pointer<TSLanguage>,
        ffi.Pointer<ffi.Char>,
        ffi.Uint32,
      )
    >
  >('ts_language_field_id_for_name');
  late final _ts_language_field_id_for_name =
      _ts_language_field_id_for_namePtr
          .asFunction<
            int Function(ffi.Pointer<TSLanguage>, ffi.Pointer<ffi.Char>, int)
          >();

  /// Get a list of all supertype symbols for the language.
  ffi.Pointer<TSSymbol> ts_language_supertypes(
    ffi.Pointer<TSLanguage> self,
    ffi.Pointer<ffi.Uint32> length,
  ) {
    return _ts_language_supertypes(self, length);
  }

  late final _ts_language_supertypesPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<TSSymbol> Function(
        ffi.Pointer<TSLanguage>,
        ffi.Pointer<ffi.Uint32>,
      )
    >
  >('ts_language_supertypes');
  late final _ts_language_supertypes =
      _ts_language_supertypesPtr
          .asFunction<
            ffi.Pointer<TSSymbol> Function(
              ffi.Pointer<TSLanguage>,
              ffi.Pointer<ffi.Uint32>,
            )
          >();

  /// Get a list of all subtype symbol ids for a given supertype symbol.
  ///
  /// See [`ts_language_supertypes`] for fetching all supertype symbols.
  ffi.Pointer<TSSymbol> ts_language_subtypes(
    ffi.Pointer<TSLanguage> self,
    int supertype,
    ffi.Pointer<ffi.Uint32> length,
  ) {
    return _ts_language_subtypes(self, supertype, length);
  }

  late final _ts_language_subtypesPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<TSSymbol> Function(
        ffi.Pointer<TSLanguage>,
        TSSymbol,
        ffi.Pointer<ffi.Uint32>,
      )
    >
  >('ts_language_subtypes');
  late final _ts_language_subtypes =
      _ts_language_subtypesPtr
          .asFunction<
            ffi.Pointer<TSSymbol> Function(
              ffi.Pointer<TSLanguage>,
              int,
              ffi.Pointer<ffi.Uint32>,
            )
          >();

  /// Get a node type string for the given numerical id.
  ffi.Pointer<ffi.Char> ts_language_symbol_name(
    ffi.Pointer<TSLanguage> self,
    int symbol,
  ) {
    return _ts_language_symbol_name(self, symbol);
  }

  late final _ts_language_symbol_namePtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<TSLanguage>, TSSymbol)
    >
  >('ts_language_symbol_name');
  late final _ts_language_symbol_name =
      _ts_language_symbol_namePtr
          .asFunction<
            ffi.Pointer<ffi.Char> Function(ffi.Pointer<TSLanguage>, int)
          >();

  /// Check whether the given node type id belongs to named nodes, anonymous nodes,
  /// or a hidden nodes.
  ///
  /// See also [`ts_node_is_named`]. Hidden nodes are never returned from the API.
  TSSymbolType ts_language_symbol_type(
    ffi.Pointer<TSLanguage> self,
    DartTSSymbol symbol,
  ) {
    return TSSymbolType.fromValue(_ts_language_symbol_type(self, symbol));
  }

  late final _ts_language_symbol_typePtr = _lookup<
    ffi.NativeFunction<
      ffi.UnsignedInt Function(ffi.Pointer<TSLanguage>, TSSymbol)
    >
  >('ts_language_symbol_type');
  late final _ts_language_symbol_type =
      _ts_language_symbol_typePtr
          .asFunction<int Function(ffi.Pointer<TSLanguage>, int)>();

  /// @deprecated use [`ts_language_abi_version`] instead, this will be removed in 0.26.
  ///
  /// Get the ABI version number for this language. This version number is used
  /// to ensure that languages were generated by a compatible version of
  /// Tree-sitter.
  ///
  /// See also [`ts_parser_set_language`].
  int ts_language_version(ffi.Pointer<TSLanguage> self) {
    return _ts_language_version(self);
  }

  late final _ts_language_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<TSLanguage>)>>(
        'ts_language_version',
      );
  late final _ts_language_version =
      _ts_language_versionPtr
          .asFunction<int Function(ffi.Pointer<TSLanguage>)>();

  /// Get the ABI version number for this language. This version number is used
  /// to ensure that languages were generated by a compatible version of
  /// Tree-sitter.
  ///
  /// See also [`ts_parser_set_language`].
  int ts_language_abi_version(ffi.Pointer<TSLanguage> self) {
    return _ts_language_abi_version(self);
  }

  late final _ts_language_abi_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<TSLanguage>)>>(
        'ts_language_abi_version',
      );
  late final _ts_language_abi_version =
      _ts_language_abi_versionPtr
          .asFunction<int Function(ffi.Pointer<TSLanguage>)>();

  /// Get the metadata for this language. This information is generated by the
  /// CLI, and relies on the language author providing the correct metadata in
  /// the language's `tree-sitter.json` file.
  ///
  /// See also [`TSMetadata`].
  ffi.Pointer<TSLanguageMetadata> ts_language_metadata(
    ffi.Pointer<TSLanguage> self,
  ) {
    return _ts_language_metadata(self);
  }

  late final _ts_language_metadataPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<TSLanguageMetadata> Function(ffi.Pointer<TSLanguage>)
    >
  >('ts_language_metadata');
  late final _ts_language_metadata =
      _ts_language_metadataPtr
          .asFunction<
            ffi.Pointer<TSLanguageMetadata> Function(ffi.Pointer<TSLanguage>)
          >();

  /// Get the next parse state. Combine this with lookahead iterators to generate
  /// completion suggestions or valid symbols in error nodes. Use
  /// [`ts_node_grammar_symbol`] for valid symbols.
  int ts_language_next_state(
    ffi.Pointer<TSLanguage> self,
    int state,
    int symbol,
  ) {
    return _ts_language_next_state(self, state, symbol);
  }

  late final _ts_language_next_statePtr = _lookup<
    ffi.NativeFunction<
      TSStateId Function(ffi.Pointer<TSLanguage>, TSStateId, TSSymbol)
    >
  >('ts_language_next_state');
  late final _ts_language_next_state =
      _ts_language_next_statePtr
          .asFunction<int Function(ffi.Pointer<TSLanguage>, int, int)>();

  /// Get the name of this language. This returns `NULL` in older parsers.
  ffi.Pointer<ffi.Char> ts_language_name(ffi.Pointer<TSLanguage> self) {
    return _ts_language_name(self);
  }

  late final _ts_language_namePtr = _lookup<
    ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<TSLanguage>)>
  >('ts_language_name');
  late final _ts_language_name =
      _ts_language_namePtr
          .asFunction<
            ffi.Pointer<ffi.Char> Function(ffi.Pointer<TSLanguage>)
          >();

  /// Create a new lookahead iterator for the given language and parse state.
  ///
  /// This returns `NULL` if state is invalid for the language.
  ///
  /// Repeatedly using [`ts_lookahead_iterator_next`] and
  /// [`ts_lookahead_iterator_current_symbol`] will generate valid symbols in the
  /// given parse state. Newly created lookahead iterators will contain the `ERROR`
  /// symbol.
  ///
  /// Lookahead iterators can be useful to generate suggestions and improve syntax
  /// error diagnostics. To get symbols valid in an ERROR node, use the lookahead
  /// iterator on its first leaf node state. For `MISSING` nodes, a lookahead
  /// iterator created on the previous non-extra leaf node may be appropriate.
  ffi.Pointer<TSLookaheadIterator> ts_lookahead_iterator_new(
    ffi.Pointer<TSLanguage> self,
    int state,
  ) {
    return _ts_lookahead_iterator_new(self, state);
  }

  late final _ts_lookahead_iterator_newPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<TSLookaheadIterator> Function(
        ffi.Pointer<TSLanguage>,
        TSStateId,
      )
    >
  >('ts_lookahead_iterator_new');
  late final _ts_lookahead_iterator_new =
      _ts_lookahead_iterator_newPtr
          .asFunction<
            ffi.Pointer<TSLookaheadIterator> Function(
              ffi.Pointer<TSLanguage>,
              int,
            )
          >();

  /// Delete a lookahead iterator freeing all the memory used.
  void ts_lookahead_iterator_delete(ffi.Pointer<TSLookaheadIterator> self) {
    return _ts_lookahead_iterator_delete(self);
  }

  late final _ts_lookahead_iterator_deletePtr = _lookup<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSLookaheadIterator>)>
  >('ts_lookahead_iterator_delete');
  late final _ts_lookahead_iterator_delete =
      _ts_lookahead_iterator_deletePtr
          .asFunction<void Function(ffi.Pointer<TSLookaheadIterator>)>();

  /// Reset the lookahead iterator to another state.
  ///
  /// This returns `true` if the iterator was reset to the given state and `false`
  /// otherwise.
  bool ts_lookahead_iterator_reset_state(
    ffi.Pointer<TSLookaheadIterator> self,
    int state,
  ) {
    return _ts_lookahead_iterator_reset_state(self, state);
  }

  late final _ts_lookahead_iterator_reset_statePtr = _lookup<
    ffi.NativeFunction<
      ffi.Bool Function(ffi.Pointer<TSLookaheadIterator>, TSStateId)
    >
  >('ts_lookahead_iterator_reset_state');
  late final _ts_lookahead_iterator_reset_state =
      _ts_lookahead_iterator_reset_statePtr
          .asFunction<bool Function(ffi.Pointer<TSLookaheadIterator>, int)>();

  /// Reset the lookahead iterator.
  ///
  /// This returns `true` if the language was set successfully and `false`
  /// otherwise.
  bool ts_lookahead_iterator_reset(
    ffi.Pointer<TSLookaheadIterator> self,
    ffi.Pointer<TSLanguage> language,
    int state,
  ) {
    return _ts_lookahead_iterator_reset(self, language, state);
  }

  late final _ts_lookahead_iterator_resetPtr = _lookup<
    ffi.NativeFunction<
      ffi.Bool Function(
        ffi.Pointer<TSLookaheadIterator>,
        ffi.Pointer<TSLanguage>,
        TSStateId,
      )
    >
  >('ts_lookahead_iterator_reset');
  late final _ts_lookahead_iterator_reset =
      _ts_lookahead_iterator_resetPtr
          .asFunction<
            bool Function(
              ffi.Pointer<TSLookaheadIterator>,
              ffi.Pointer<TSLanguage>,
              int,
            )
          >();

  /// Get the current language of the lookahead iterator.
  ffi.Pointer<TSLanguage> ts_lookahead_iterator_language(
    ffi.Pointer<TSLookaheadIterator> self,
  ) {
    return _ts_lookahead_iterator_language(self);
  }

  late final _ts_lookahead_iterator_languagePtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<TSLanguage> Function(ffi.Pointer<TSLookaheadIterator>)
    >
  >('ts_lookahead_iterator_language');
  late final _ts_lookahead_iterator_language =
      _ts_lookahead_iterator_languagePtr
          .asFunction<
            ffi.Pointer<TSLanguage> Function(ffi.Pointer<TSLookaheadIterator>)
          >();

  /// Advance the lookahead iterator to the next symbol.
  ///
  /// This returns `true` if there is a new symbol and `false` otherwise.
  bool ts_lookahead_iterator_next(ffi.Pointer<TSLookaheadIterator> self) {
    return _ts_lookahead_iterator_next(self);
  }

  late final _ts_lookahead_iterator_nextPtr = _lookup<
    ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TSLookaheadIterator>)>
  >('ts_lookahead_iterator_next');
  late final _ts_lookahead_iterator_next =
      _ts_lookahead_iterator_nextPtr
          .asFunction<bool Function(ffi.Pointer<TSLookaheadIterator>)>();

  /// Get the current symbol of the lookahead iterator;
  int ts_lookahead_iterator_current_symbol(
    ffi.Pointer<TSLookaheadIterator> self,
  ) {
    return _ts_lookahead_iterator_current_symbol(self);
  }

  late final _ts_lookahead_iterator_current_symbolPtr = _lookup<
    ffi.NativeFunction<TSSymbol Function(ffi.Pointer<TSLookaheadIterator>)>
  >('ts_lookahead_iterator_current_symbol');
  late final _ts_lookahead_iterator_current_symbol =
      _ts_lookahead_iterator_current_symbolPtr
          .asFunction<int Function(ffi.Pointer<TSLookaheadIterator>)>();

  /// Get the current symbol type of the lookahead iterator as a null terminated
  /// string.
  ffi.Pointer<ffi.Char> ts_lookahead_iterator_current_symbol_name(
    ffi.Pointer<TSLookaheadIterator> self,
  ) {
    return _ts_lookahead_iterator_current_symbol_name(self);
  }

  late final _ts_lookahead_iterator_current_symbol_namePtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<TSLookaheadIterator>)
    >
  >('ts_lookahead_iterator_current_symbol_name');
  late final _ts_lookahead_iterator_current_symbol_name =
      _ts_lookahead_iterator_current_symbol_namePtr
          .asFunction<
            ffi.Pointer<ffi.Char> Function(ffi.Pointer<TSLookaheadIterator>)
          >();

  /// Create a Wasm store.
  ffi.Pointer<TSWasmStore> ts_wasm_store_new(
    ffi.Pointer<TSWasmEngine> engine,
    ffi.Pointer<TSWasmError> error,
  ) {
    return _ts_wasm_store_new(engine, error);
  }

  late final _ts_wasm_store_newPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<TSWasmStore> Function(
        ffi.Pointer<TSWasmEngine>,
        ffi.Pointer<TSWasmError>,
      )
    >
  >('ts_wasm_store_new');
  late final _ts_wasm_store_new =
      _ts_wasm_store_newPtr
          .asFunction<
            ffi.Pointer<TSWasmStore> Function(
              ffi.Pointer<TSWasmEngine>,
              ffi.Pointer<TSWasmError>,
            )
          >();

  /// Free the memory associated with the given Wasm store.
  void ts_wasm_store_delete(ffi.Pointer<TSWasmStore> arg0) {
    return _ts_wasm_store_delete(arg0);
  }

  late final _ts_wasm_store_deletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TSWasmStore>)>>(
        'ts_wasm_store_delete',
      );
  late final _ts_wasm_store_delete =
      _ts_wasm_store_deletePtr
          .asFunction<void Function(ffi.Pointer<TSWasmStore>)>();

  /// Create a language from a buffer of Wasm. The resulting language behaves
  /// like any other Tree-sitter language, except that in order to use it with
  /// a parser, that parser must have a Wasm store. Note that the language
  /// can be used with any Wasm store, it doesn't need to be the same store that
  /// was used to originally load it.
  ffi.Pointer<TSLanguage> ts_wasm_store_load_language(
    ffi.Pointer<TSWasmStore> arg0,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> wasm,
    int wasm_len,
    ffi.Pointer<TSWasmError> error,
  ) {
    return _ts_wasm_store_load_language(arg0, name, wasm, wasm_len, error);
  }

  late final _ts_wasm_store_load_languagePtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<TSLanguage> Function(
        ffi.Pointer<TSWasmStore>,
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Char>,
        ffi.Uint32,
        ffi.Pointer<TSWasmError>,
      )
    >
  >('ts_wasm_store_load_language');
  late final _ts_wasm_store_load_language =
      _ts_wasm_store_load_languagePtr
          .asFunction<
            ffi.Pointer<TSLanguage> Function(
              ffi.Pointer<TSWasmStore>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<TSWasmError>,
            )
          >();

  /// Get the number of languages instantiated in the given wasm store.
  int ts_wasm_store_language_count(ffi.Pointer<TSWasmStore> arg0) {
    return _ts_wasm_store_language_count(arg0);
  }

  late final _ts_wasm_store_language_countPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<TSWasmStore>)>>(
        'ts_wasm_store_language_count',
      );
  late final _ts_wasm_store_language_count =
      _ts_wasm_store_language_countPtr
          .asFunction<int Function(ffi.Pointer<TSWasmStore>)>();

  /// Check if the language came from a Wasm module. If so, then in order to use
  /// this language with a Parser, that parser must have a Wasm store assigned.
  bool ts_language_is_wasm(ffi.Pointer<TSLanguage> arg0) {
    return _ts_language_is_wasm(arg0);
  }

  late final _ts_language_is_wasmPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TSLanguage>)>>(
        'ts_language_is_wasm',
      );
  late final _ts_language_is_wasm =
      _ts_language_is_wasmPtr
          .asFunction<bool Function(ffi.Pointer<TSLanguage>)>();

  /// Assign the given Wasm store to the parser. A parser must have a Wasm store
  /// in order to use Wasm languages.
  void ts_parser_set_wasm_store(
    ffi.Pointer<TSParser> arg0,
    ffi.Pointer<TSWasmStore> arg1,
  ) {
    return _ts_parser_set_wasm_store(arg0, arg1);
  }

  late final _ts_parser_set_wasm_storePtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<TSParser>, ffi.Pointer<TSWasmStore>)
    >
  >('ts_parser_set_wasm_store');
  late final _ts_parser_set_wasm_store =
      _ts_parser_set_wasm_storePtr
          .asFunction<
            void Function(ffi.Pointer<TSParser>, ffi.Pointer<TSWasmStore>)
          >();

  /// Remove the parser's current Wasm store and return it. This returns NULL if
  /// the parser doesn't have a Wasm store.
  ffi.Pointer<TSWasmStore> ts_parser_take_wasm_store(
    ffi.Pointer<TSParser> arg0,
  ) {
    return _ts_parser_take_wasm_store(arg0);
  }

  late final _ts_parser_take_wasm_storePtr = _lookup<
    ffi.NativeFunction<ffi.Pointer<TSWasmStore> Function(ffi.Pointer<TSParser>)>
  >('ts_parser_take_wasm_store');
  late final _ts_parser_take_wasm_store =
      _ts_parser_take_wasm_storePtr
          .asFunction<
            ffi.Pointer<TSWasmStore> Function(ffi.Pointer<TSParser>)
          >();

  /// Set the allocation functions used by the library.
  ///
  /// By default, Tree-sitter uses the standard libc allocation functions,
  /// but aborts the process when an allocation fails. This function lets
  /// you supply alternative allocation functions at runtime.
  ///
  /// If you pass `NULL` for any parameter, Tree-sitter will switch back to
  /// its default implementation of that function.
  ///
  /// If you call this function after the library has already been used, then
  /// you must ensure that either:
  /// 1. All the existing objects have been freed.
  /// 2. The new allocator shares its state with the old one, so it is capable
  /// of freeing memory that was allocated by the old allocator.
  void ts_set_allocator(
    ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>
    new_malloc,
    ffi.Pointer<
      ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>
    >
    new_calloc,
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Size)
      >
    >
    new_realloc,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
    new_free,
  ) {
    return _ts_set_allocator(new_malloc, new_calloc, new_realloc, new_free);
  }

  late final _ts_set_allocatorPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(
        ffi.Pointer<
          ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>
        >,
        ffi.Pointer<
          ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>
        >,
        ffi.Pointer<
          ffi.NativeFunction<
            ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Size)
          >
        >,
        ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>
        >,
      )
    >
  >('ts_set_allocator');
  late final _ts_set_allocator =
      _ts_set_allocatorPtr
          .asFunction<
            void Function(
              ffi.Pointer<
                ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>
              >,
              ffi.Pointer<
                ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)
                >
              >,
              ffi.Pointer<
                ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Size,
                  )
                >
              >,
              ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>
              >,
            )
          >();
}

typedef __int8_t = ffi.SignedChar;
typedef Dart__int8_t = int;
typedef __uint8_t = ffi.UnsignedChar;
typedef Dart__uint8_t = int;
typedef __int16_t = ffi.Short;
typedef Dart__int16_t = int;
typedef __uint16_t = ffi.UnsignedShort;
typedef Dart__uint16_t = int;
typedef __int32_t = ffi.Int;
typedef Dart__int32_t = int;
typedef __uint32_t = ffi.UnsignedInt;
typedef Dart__uint32_t = int;
typedef __int64_t = ffi.LongLong;
typedef Dart__int64_t = int;
typedef __uint64_t = ffi.UnsignedLongLong;
typedef Dart__uint64_t = int;
typedef __darwin_intptr_t = ffi.Long;
typedef Dart__darwin_intptr_t = int;
typedef __darwin_natural_t = ffi.UnsignedInt;
typedef Dart__darwin_natural_t = int;
typedef __darwin_ct_rune_t = ffi.Int;
typedef Dart__darwin_ct_rune_t = int;

final class __mbstate_t extends ffi.Union {
  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> __mbstate8;

  @ffi.LongLong()
  external int _mbstateL;
}

typedef __darwin_mbstate_t = __mbstate_t;
typedef __darwin_ptrdiff_t = ffi.Long;
typedef Dart__darwin_ptrdiff_t = int;
typedef __darwin_size_t = ffi.UnsignedLong;
typedef Dart__darwin_size_t = int;
typedef __builtin_va_list = ffi.Pointer<ffi.Char>;
typedef __darwin_va_list = __builtin_va_list;
typedef __darwin_wchar_t = ffi.Int;
typedef Dart__darwin_wchar_t = int;
typedef __darwin_rune_t = __darwin_wchar_t;
typedef __darwin_wint_t = ffi.Int;
typedef Dart__darwin_wint_t = int;
typedef __darwin_clock_t = ffi.UnsignedLong;
typedef Dart__darwin_clock_t = int;
typedef __darwin_socklen_t = __uint32_t;
typedef __darwin_ssize_t = ffi.Long;
typedef Dart__darwin_ssize_t = int;
typedef __darwin_time_t = ffi.Long;
typedef Dart__darwin_time_t = int;
typedef __darwin_blkcnt_t = __int64_t;
typedef __darwin_blksize_t = __int32_t;
typedef __darwin_dev_t = __int32_t;
typedef __darwin_fsblkcnt_t = ffi.UnsignedInt;
typedef Dart__darwin_fsblkcnt_t = int;
typedef __darwin_fsfilcnt_t = ffi.UnsignedInt;
typedef Dart__darwin_fsfilcnt_t = int;
typedef __darwin_gid_t = __uint32_t;
typedef __darwin_id_t = __uint32_t;
typedef __darwin_ino64_t = __uint64_t;
typedef __darwin_ino_t = __darwin_ino64_t;
typedef __darwin_mach_port_name_t = __darwin_natural_t;
typedef __darwin_mach_port_t = __darwin_mach_port_name_t;
typedef __darwin_mode_t = __uint16_t;
typedef __darwin_off_t = __int64_t;
typedef __darwin_pid_t = __int32_t;
typedef __darwin_sigset_t = __uint32_t;
typedef __darwin_suseconds_t = __int32_t;
typedef __darwin_uid_t = __uint32_t;
typedef __darwin_useconds_t = __uint32_t;

final class __darwin_pthread_handler_rec extends ffi.Struct {
  external ffi.Pointer<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>
  >
  __routine;

  external ffi.Pointer<ffi.Void> __arg;

  external ffi.Pointer<__darwin_pthread_handler_rec> __next;
}

final class _opaque_pthread_attr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_cond_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([40])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_condattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_mutex_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_mutexattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_once_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_rwlock_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([192])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_rwlockattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  external ffi.Pointer<__darwin_pthread_handler_rec> __cleanup_stack;

  @ffi.Array.multi([8176])
  external ffi.Array<ffi.Char> __opaque;
}

typedef __darwin_pthread_attr_t = _opaque_pthread_attr_t;
typedef __darwin_pthread_cond_t = _opaque_pthread_cond_t;
typedef __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
typedef __darwin_pthread_key_t = ffi.UnsignedLong;
typedef Dart__darwin_pthread_key_t = int;
typedef __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
typedef __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
typedef __darwin_pthread_once_t = _opaque_pthread_once_t;
typedef __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
typedef __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
typedef __darwin_pthread_t = ffi.Pointer<_opaque_pthread_t>;
typedef __darwin_nl_item = ffi.Int;
typedef Dart__darwin_nl_item = int;
typedef __darwin_wctrans_t = ffi.Int;
typedef Dart__darwin_wctrans_t = int;
typedef __darwin_wctype_t = __uint32_t;

enum idtype_t {
  P_ALL(0),
  P_PID(1),
  P_PGID(2);

  final int value;
  const idtype_t(this.value);

  static idtype_t fromValue(int value) => switch (value) {
    0 => P_ALL,
    1 => P_PID,
    2 => P_PGID,
    _ => throw ArgumentError("Unknown value for idtype_t: $value"),
  };
}

typedef pid_t = __darwin_pid_t;
typedef id_t = __darwin_id_t;
typedef sig_atomic_t = ffi.Int;
typedef Dartsig_atomic_t = int;
typedef u_int8_t = ffi.UnsignedChar;
typedef Dartu_int8_t = int;
typedef u_int16_t = ffi.UnsignedShort;
typedef Dartu_int16_t = int;
typedef u_int32_t = ffi.UnsignedInt;
typedef Dartu_int32_t = int;
typedef u_int64_t = ffi.UnsignedLongLong;
typedef Dartu_int64_t = int;
typedef register_t = ffi.Int64;
typedef Dartregister_t = int;
typedef user_addr_t = u_int64_t;
typedef user_size_t = u_int64_t;
typedef user_ssize_t = ffi.Int64;
typedef Dartuser_ssize_t = int;
typedef user_long_t = ffi.Int64;
typedef Dartuser_long_t = int;
typedef user_ulong_t = u_int64_t;
typedef user_time_t = ffi.Int64;
typedef Dartuser_time_t = int;
typedef user_off_t = ffi.Int64;
typedef Dartuser_off_t = int;
typedef syscall_arg_t = u_int64_t;

final class __darwin_arm_exception_state extends ffi.Struct {
  @__uint32_t()
  external int __exception;

  @__uint32_t()
  external int __fsr;

  @__uint32_t()
  external int __far;
}

final class __darwin_arm_exception_state64 extends ffi.Struct {
  @__uint64_t()
  external int __far;

  @__uint32_t()
  external int __esr;

  @__uint32_t()
  external int __exception;
}

final class __darwin_arm_exception_state64_v2 extends ffi.Struct {
  @__uint64_t()
  external int __far;

  @__uint64_t()
  external int __esr;
}

final class __darwin_arm_thread_state extends ffi.Struct {
  @ffi.Array.multi([13])
  external ffi.Array<__uint32_t> __r;

  @__uint32_t()
  external int __sp;

  @__uint32_t()
  external int __lr;

  @__uint32_t()
  external int __pc;

  @__uint32_t()
  external int __cpsr;
}

final class __darwin_arm_thread_state64 extends ffi.Struct {
  @ffi.Array.multi([29])
  external ffi.Array<__uint64_t> __x;

  @__uint64_t()
  external int __fp;

  @__uint64_t()
  external int __lr;

  @__uint64_t()
  external int __sp;

  @__uint64_t()
  external int __pc;

  @__uint32_t()
  external int __cpsr;

  @__uint32_t()
  external int __pad;
}

final class __darwin_arm_vfp_state extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<__uint32_t> __r;

  @__uint32_t()
  external int __fpscr;
}

final class __darwin_arm_neon_state64 extends ffi.Opaque {}

final class __darwin_arm_neon_state extends ffi.Opaque {}

final class __arm_pagein_state extends ffi.Struct {
  @ffi.Int()
  external int __pagein_error;
}

final class __arm_legacy_debug_state extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bcr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wcr;
}

final class __darwin_arm_debug_state32 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bcr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wcr;

  @__uint64_t()
  external int __mdscr_el1;
}

final class __darwin_arm_debug_state64 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __bvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __bcr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __wvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __wcr;

  @__uint64_t()
  external int __mdscr_el1;
}

final class __darwin_arm_cpmu_state64 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __ctrs;
}

final class __darwin_mcontext32 extends ffi.Struct {
  external __darwin_arm_exception_state __es;

  external __darwin_arm_thread_state __ss;

  external __darwin_arm_vfp_state __fs;
}

final class __darwin_mcontext64 extends ffi.Opaque {}

typedef mcontext_t = ffi.Pointer<__darwin_mcontext64>;
typedef pthread_attr_t = __darwin_pthread_attr_t;

final class __darwin_sigaltstack extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ss_sp;

  @__darwin_size_t()
  external int ss_size;

  @ffi.Int()
  external int ss_flags;
}

typedef stack_t = __darwin_sigaltstack;

final class __darwin_ucontext extends ffi.Struct {
  @ffi.Int()
  external int uc_onstack;

  @__darwin_sigset_t()
  external int uc_sigmask;

  external __darwin_sigaltstack uc_stack;

  external ffi.Pointer<__darwin_ucontext> uc_link;

  @__darwin_size_t()
  external int uc_mcsize;

  external ffi.Pointer<__darwin_mcontext64> uc_mcontext;
}

typedef ucontext_t = __darwin_ucontext;
typedef sigset_t = __darwin_sigset_t;
typedef uid_t = __darwin_uid_t;

final class sigval extends ffi.Union {
  @ffi.Int()
  external int sival_int;

  external ffi.Pointer<ffi.Void> sival_ptr;
}

final class sigevent extends ffi.Struct {
  @ffi.Int()
  external int sigev_notify;

  @ffi.Int()
  external int sigev_signo;

  external sigval sigev_value;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(sigval)>>
  sigev_notify_function;

  external ffi.Pointer<pthread_attr_t> sigev_notify_attributes;
}

final class __siginfo extends ffi.Struct {
  @ffi.Int()
  external int si_signo;

  @ffi.Int()
  external int si_errno;

  @ffi.Int()
  external int si_code;

  @pid_t()
  external int si_pid;

  @uid_t()
  external int si_uid;

  @ffi.Int()
  external int si_status;

  external ffi.Pointer<ffi.Void> si_addr;

  external sigval si_value;

  @ffi.Long()
  external int si_band;

  @ffi.Array.multi([7])
  external ffi.Array<ffi.UnsignedLong> __pad;
}

typedef siginfo_t = __siginfo;

final class __sigaction_u extends ffi.Union {
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>
  __sa_handler;

  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Int, ffi.Pointer<__siginfo>, ffi.Pointer<ffi.Void>)
    >
  >
  __sa_sigaction;
}

final class __sigaction extends ffi.Struct {
  external __sigaction_u __sigaction_u1;

  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Int,
        ffi.Int,
        ffi.Pointer<siginfo_t>,
        ffi.Pointer<ffi.Void>,
      )
    >
  >
  sa_tramp;

  @sigset_t()
  external int sa_mask;

  @ffi.Int()
  external int sa_flags;
}

final class sigaction extends ffi.Struct {
  external __sigaction_u __sigaction_u1;

  @sigset_t()
  external int sa_mask;

  @ffi.Int()
  external int sa_flags;
}

typedef sig_tFunction = ffi.Void Function(ffi.Int);
typedef Dartsig_tFunction = void Function(int);
typedef sig_t = ffi.Pointer<ffi.NativeFunction<sig_tFunction>>;

final class sigvec extends ffi.Struct {
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>
  sv_handler;

  @ffi.Int()
  external int sv_mask;

  @ffi.Int()
  external int sv_flags;
}

final class sigstack extends ffi.Struct {
  external ffi.Pointer<ffi.Char> ss_sp;

  @ffi.Int()
  external int ss_onstack;
}

typedef int_least8_t = ffi.Int8;
typedef Dartint_least8_t = int;
typedef int_least16_t = ffi.Int16;
typedef Dartint_least16_t = int;
typedef int_least32_t = ffi.Int32;
typedef Dartint_least32_t = int;
typedef int_least64_t = ffi.Int64;
typedef Dartint_least64_t = int;
typedef uint_least8_t = ffi.Uint8;
typedef Dartuint_least8_t = int;
typedef uint_least16_t = ffi.Uint16;
typedef Dartuint_least16_t = int;
typedef uint_least32_t = ffi.Uint32;
typedef Dartuint_least32_t = int;
typedef uint_least64_t = ffi.Uint64;
typedef Dartuint_least64_t = int;
typedef int_fast8_t = ffi.Int8;
typedef Dartint_fast8_t = int;
typedef int_fast16_t = ffi.Int16;
typedef Dartint_fast16_t = int;
typedef int_fast32_t = ffi.Int32;
typedef Dartint_fast32_t = int;
typedef int_fast64_t = ffi.Int64;
typedef Dartint_fast64_t = int;
typedef uint_fast8_t = ffi.Uint8;
typedef Dartuint_fast8_t = int;
typedef uint_fast16_t = ffi.Uint16;
typedef Dartuint_fast16_t = int;
typedef uint_fast32_t = ffi.Uint32;
typedef Dartuint_fast32_t = int;
typedef uint_fast64_t = ffi.Uint64;
typedef Dartuint_fast64_t = int;
typedef intmax_t = ffi.Long;
typedef Dartintmax_t = int;
typedef uintmax_t = ffi.UnsignedLong;
typedef Dartuintmax_t = int;

final class timeval extends ffi.Struct {
  @__darwin_time_t()
  external int tv_sec;

  @__darwin_suseconds_t()
  external int tv_usec;
}

typedef rlim_t = __uint64_t;

final class rusage extends ffi.Struct {
  external timeval ru_utime;

  external timeval ru_stime;

  @ffi.Long()
  external int ru_maxrss;

  @ffi.Long()
  external int ru_ixrss;

  @ffi.Long()
  external int ru_idrss;

  @ffi.Long()
  external int ru_isrss;

  @ffi.Long()
  external int ru_minflt;

  @ffi.Long()
  external int ru_majflt;

  @ffi.Long()
  external int ru_nswap;

  @ffi.Long()
  external int ru_inblock;

  @ffi.Long()
  external int ru_oublock;

  @ffi.Long()
  external int ru_msgsnd;

  @ffi.Long()
  external int ru_msgrcv;

  @ffi.Long()
  external int ru_nsignals;

  @ffi.Long()
  external int ru_nvcsw;

  @ffi.Long()
  external int ru_nivcsw;
}

typedef rusage_info_t = ffi.Pointer<ffi.Void>;

final class rusage_info_v0 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;
}

final class rusage_info_v1 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;
}

final class rusage_info_v2 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;
}

final class rusage_info_v3 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;
}

final class rusage_info_v4 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;

  @ffi.Uint64()
  external int ri_logical_writes;

  @ffi.Uint64()
  external int ri_lifetime_max_phys_footprint;

  @ffi.Uint64()
  external int ri_instructions;

  @ffi.Uint64()
  external int ri_cycles;

  @ffi.Uint64()
  external int ri_billed_energy;

  @ffi.Uint64()
  external int ri_serviced_energy;

  @ffi.Uint64()
  external int ri_interval_max_phys_footprint;

  @ffi.Uint64()
  external int ri_runnable_time;
}

final class rusage_info_v5 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;

  @ffi.Uint64()
  external int ri_logical_writes;

  @ffi.Uint64()
  external int ri_lifetime_max_phys_footprint;

  @ffi.Uint64()
  external int ri_instructions;

  @ffi.Uint64()
  external int ri_cycles;

  @ffi.Uint64()
  external int ri_billed_energy;

  @ffi.Uint64()
  external int ri_serviced_energy;

  @ffi.Uint64()
  external int ri_interval_max_phys_footprint;

  @ffi.Uint64()
  external int ri_runnable_time;

  @ffi.Uint64()
  external int ri_flags;
}

final class rusage_info_v6 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;

  @ffi.Uint64()
  external int ri_logical_writes;

  @ffi.Uint64()
  external int ri_lifetime_max_phys_footprint;

  @ffi.Uint64()
  external int ri_instructions;

  @ffi.Uint64()
  external int ri_cycles;

  @ffi.Uint64()
  external int ri_billed_energy;

  @ffi.Uint64()
  external int ri_serviced_energy;

  @ffi.Uint64()
  external int ri_interval_max_phys_footprint;

  @ffi.Uint64()
  external int ri_runnable_time;

  @ffi.Uint64()
  external int ri_flags;

  @ffi.Uint64()
  external int ri_user_ptime;

  @ffi.Uint64()
  external int ri_system_ptime;

  @ffi.Uint64()
  external int ri_pinstructions;

  @ffi.Uint64()
  external int ri_pcycles;

  @ffi.Uint64()
  external int ri_energy_nj;

  @ffi.Uint64()
  external int ri_penergy_nj;

  @ffi.Uint64()
  external int ri_secure_time_in_system;

  @ffi.Uint64()
  external int ri_secure_ptime_in_system;

  @ffi.Uint64()
  external int ri_neural_footprint;

  @ffi.Uint64()
  external int ri_lifetime_max_neural_footprint;

  @ffi.Uint64()
  external int ri_interval_max_neural_footprint;

  @ffi.Array.multi([9])
  external ffi.Array<ffi.Uint64> ri_reserved;
}

typedef rusage_info_current = rusage_info_v6;

final class rlimit extends ffi.Struct {
  @rlim_t()
  external int rlim_cur;

  @rlim_t()
  external int rlim_max;
}

final class proc_rlimit_control_wakeupmon extends ffi.Struct {
  @ffi.Uint32()
  external int wm_flags;

  @ffi.Int32()
  external int wm_rate;
}

final class wait extends ffi.Opaque {}

typedef ct_rune_t = __darwin_ct_rune_t;
typedef rune_t = __darwin_rune_t;

final class div_t extends ffi.Struct {
  @ffi.Int()
  external int quot;

  @ffi.Int()
  external int rem;
}

final class ldiv_t extends ffi.Struct {
  @ffi.Long()
  external int quot;

  @ffi.Long()
  external int rem;
}

final class lldiv_t extends ffi.Struct {
  @ffi.LongLong()
  external int quot;

  @ffi.LongLong()
  external int rem;
}

typedef malloc_type_id_t = ffi.UnsignedLongLong;
typedef Dartmalloc_type_id_t = int;

final class _malloc_zone_t extends ffi.Opaque {}

typedef malloc_zone_t = _malloc_zone_t;
typedef dev_t = __darwin_dev_t;
typedef mode_t = __darwin_mode_t;

/// /
typedef TSStateId = ffi.Uint16;
typedef DartTSStateId = int;
typedef TSSymbol = ffi.Uint16;
typedef DartTSSymbol = int;
typedef TSFieldId = ffi.Uint16;
typedef DartTSFieldId = int;

final class TSLanguage extends ffi.Opaque {}

/// The metadata associated with a language.
///
/// Currently, this metadata can be used to check the [Semantic Version](https://semver.org/)
/// of the language. This version information should be used to signal if a given parser might
/// be incompatible with existing queries when upgrading between major versions, or minor versions
/// if it's in zerover.
final class TSLanguageMetadata extends ffi.Struct {
  @ffi.Uint8()
  external int major_version;

  @ffi.Uint8()
  external int minor_version;

  @ffi.Uint8()
  external int patch_version;
}

final class TSParser extends ffi.Opaque {}

final class TSTree extends ffi.Opaque {}

final class TSQuery extends ffi.Opaque {}

final class TSQueryCursor extends ffi.Opaque {}

final class TSLookaheadIterator extends ffi.Opaque {}

typedef DecodeFunctionFunction =
    ffi.Uint32 Function(
      ffi.Pointer<ffi.Uint8> string,
      ffi.Uint32 length,
      ffi.Pointer<ffi.Int32> code_point,
    );
typedef DartDecodeFunctionFunction =
    int Function(
      ffi.Pointer<ffi.Uint8> string,
      int length,
      ffi.Pointer<ffi.Int32> code_point,
    );
typedef DecodeFunction =
    ffi.Pointer<ffi.NativeFunction<DecodeFunctionFunction>>;

enum TSInputEncoding {
  TSInputEncodingUTF8(0),
  TSInputEncodingUTF16LE(1),
  TSInputEncodingUTF16BE(2),
  TSInputEncodingCustom(3);

  final int value;
  const TSInputEncoding(this.value);

  static TSInputEncoding fromValue(int value) => switch (value) {
    0 => TSInputEncodingUTF8,
    1 => TSInputEncodingUTF16LE,
    2 => TSInputEncodingUTF16BE,
    3 => TSInputEncodingCustom,
    _ => throw ArgumentError("Unknown value for TSInputEncoding: $value"),
  };
}

enum TSSymbolType {
  TSSymbolTypeRegular(0),
  TSSymbolTypeAnonymous(1),
  TSSymbolTypeSupertype(2),
  TSSymbolTypeAuxiliary(3);

  final int value;
  const TSSymbolType(this.value);

  static TSSymbolType fromValue(int value) => switch (value) {
    0 => TSSymbolTypeRegular,
    1 => TSSymbolTypeAnonymous,
    2 => TSSymbolTypeSupertype,
    3 => TSSymbolTypeAuxiliary,
    _ => throw ArgumentError("Unknown value for TSSymbolType: $value"),
  };
}

final class TSPoint extends ffi.Struct {
  @ffi.Uint32()
  external int row;

  @ffi.Uint32()
  external int column;
}

final class TSRange extends ffi.Struct {
  external TSPoint start_point;

  external TSPoint end_point;

  @ffi.Uint32()
  external int start_byte;

  @ffi.Uint32()
  external int end_byte;
}

final class TSInput extends ffi.Struct {
  external ffi.Pointer<ffi.Void> payload;

  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Pointer<ffi.Char> Function(
        ffi.Pointer<ffi.Void> payload,
        ffi.Uint32 byte_index,
        TSPoint position,
        ffi.Pointer<ffi.Uint32> bytes_read,
      )
    >
  >
  read;

  @ffi.UnsignedInt()
  external int encodingAsInt;

  TSInputEncoding get encoding => TSInputEncoding.fromValue(encodingAsInt);

  external DecodeFunction decode;
}

final class TSParseState extends ffi.Struct {
  external ffi.Pointer<ffi.Void> payload;

  @ffi.Uint32()
  external int current_byte_offset;

  @ffi.Bool()
  external bool has_error;
}

final class TSParseOptions extends ffi.Struct {
  external ffi.Pointer<ffi.Void> payload;

  external ffi.Pointer<
    ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TSParseState> state)>
  >
  progress_callback;
}

enum TSLogType {
  TSLogTypeParse(0),
  TSLogTypeLex(1);

  final int value;
  const TSLogType(this.value);

  static TSLogType fromValue(int value) => switch (value) {
    0 => TSLogTypeParse,
    1 => TSLogTypeLex,
    _ => throw ArgumentError("Unknown value for TSLogType: $value"),
  };
}

final class TSLogger extends ffi.Struct {
  external ffi.Pointer<ffi.Void> payload;

  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Void Function(
        ffi.Pointer<ffi.Void> payload,
        ffi.UnsignedInt log_type,
        ffi.Pointer<ffi.Char> buffer,
      )
    >
  >
  log;
}

final class TSInputEdit extends ffi.Struct {
  @ffi.Uint32()
  external int start_byte;

  @ffi.Uint32()
  external int old_end_byte;

  @ffi.Uint32()
  external int new_end_byte;

  external TSPoint start_point;

  external TSPoint old_end_point;

  external TSPoint new_end_point;
}

final class TSNode extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Uint32> context;

  external ffi.Pointer<ffi.Void> id;

  external ffi.Pointer<TSTree> tree;
}

final class TSTreeCursor extends ffi.Struct {
  external ffi.Pointer<ffi.Void> tree;

  external ffi.Pointer<ffi.Void> id;

  @ffi.Array.multi([3])
  external ffi.Array<ffi.Uint32> context;
}

final class TSQueryCapture extends ffi.Struct {
  external TSNode node;

  @ffi.Uint32()
  external int index;
}

enum TSQuantifier {
  TSQuantifierZero(0),
  TSQuantifierZeroOrOne(1),
  TSQuantifierZeroOrMore(2),
  TSQuantifierOne(3),
  TSQuantifierOneOrMore(4);

  final int value;
  const TSQuantifier(this.value);

  static TSQuantifier fromValue(int value) => switch (value) {
    0 => TSQuantifierZero,
    1 => TSQuantifierZeroOrOne,
    2 => TSQuantifierZeroOrMore,
    3 => TSQuantifierOne,
    4 => TSQuantifierOneOrMore,
    _ => throw ArgumentError("Unknown value for TSQuantifier: $value"),
  };
}

final class TSQueryMatch extends ffi.Struct {
  @ffi.Uint32()
  external int id;

  @ffi.Uint16()
  external int pattern_index;

  @ffi.Uint16()
  external int capture_count;

  external ffi.Pointer<TSQueryCapture> captures;
}

enum TSQueryPredicateStepType {
  TSQueryPredicateStepTypeDone(0),
  TSQueryPredicateStepTypeCapture(1),
  TSQueryPredicateStepTypeString(2);

  final int value;
  const TSQueryPredicateStepType(this.value);

  static TSQueryPredicateStepType fromValue(int value) => switch (value) {
    0 => TSQueryPredicateStepTypeDone,
    1 => TSQueryPredicateStepTypeCapture,
    2 => TSQueryPredicateStepTypeString,
    _ =>
      throw ArgumentError("Unknown value for TSQueryPredicateStepType: $value"),
  };
}

final class TSQueryPredicateStep extends ffi.Struct {
  @ffi.UnsignedInt()
  external int typeAsInt;

  TSQueryPredicateStepType get type =>
      TSQueryPredicateStepType.fromValue(typeAsInt);

  @ffi.Uint32()
  external int value_id;
}

enum TSQueryError {
  TSQueryErrorNone(0),
  TSQueryErrorSyntax(1),
  TSQueryErrorNodeType(2),
  TSQueryErrorField(3),
  TSQueryErrorCapture(4),
  TSQueryErrorStructure(5),
  TSQueryErrorLanguage(6);

  final int value;
  const TSQueryError(this.value);

  static TSQueryError fromValue(int value) => switch (value) {
    0 => TSQueryErrorNone,
    1 => TSQueryErrorSyntax,
    2 => TSQueryErrorNodeType,
    3 => TSQueryErrorField,
    4 => TSQueryErrorCapture,
    5 => TSQueryErrorStructure,
    6 => TSQueryErrorLanguage,
    _ => throw ArgumentError("Unknown value for TSQueryError: $value"),
  };
}

final class TSQueryCursorState extends ffi.Struct {
  external ffi.Pointer<ffi.Void> payload;

  @ffi.Uint32()
  external int current_byte_offset;
}

final class TSQueryCursorOptions extends ffi.Struct {
  external ffi.Pointer<ffi.Void> payload;

  external ffi.Pointer<
    ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TSQueryCursorState> state)>
  >
  progress_callback;
}

final class wasm_engine_t extends ffi.Opaque {}

/// /
typedef TSWasmEngine = wasm_engine_t;

final class TSWasmStore extends ffi.Opaque {}

enum TSWasmErrorKind {
  TSWasmErrorKindNone(0),
  TSWasmErrorKindParse(1),
  TSWasmErrorKindCompile(2),
  TSWasmErrorKindInstantiate(3),
  TSWasmErrorKindAllocate(4);

  final int value;
  const TSWasmErrorKind(this.value);

  static TSWasmErrorKind fromValue(int value) => switch (value) {
    0 => TSWasmErrorKindNone,
    1 => TSWasmErrorKindParse,
    2 => TSWasmErrorKindCompile,
    3 => TSWasmErrorKindInstantiate,
    4 => TSWasmErrorKindAllocate,
    _ => throw ArgumentError("Unknown value for TSWasmErrorKind: $value"),
  };
}

final class TSWasmError extends ffi.Struct {
  @ffi.UnsignedInt()
  external int kindAsInt;

  TSWasmErrorKind get kind => TSWasmErrorKind.fromValue(kindAsInt);

  external ffi.Pointer<ffi.Char> message;
}

const int __API_TO_BE_DEPRECATED = 100000;

const int __API_TO_BE_DEPRECATED_MACOS = 100000;

const int __API_TO_BE_DEPRECATED_IOS = 100000;

const int __API_TO_BE_DEPRECATED_MACCATALYST = 100000;

const int __API_TO_BE_DEPRECATED_WATCHOS = 100000;

const int __API_TO_BE_DEPRECATED_TVOS = 100000;

const int __API_TO_BE_DEPRECATED_DRIVERKIT = 100000;

const int __API_TO_BE_DEPRECATED_VISIONOS = 100000;

const int __MAC_10_0 = 1000;

const int __MAC_10_1 = 1010;

const int __MAC_10_2 = 1020;

const int __MAC_10_3 = 1030;

const int __MAC_10_4 = 1040;

const int __MAC_10_5 = 1050;

const int __MAC_10_6 = 1060;

const int __MAC_10_7 = 1070;

const int __MAC_10_8 = 1080;

const int __MAC_10_9 = 1090;

const int __MAC_10_10 = 101000;

const int __MAC_10_10_2 = 101002;

const int __MAC_10_10_3 = 101003;

const int __MAC_10_11 = 101100;

const int __MAC_10_11_2 = 101102;

const int __MAC_10_11_3 = 101103;

const int __MAC_10_11_4 = 101104;

const int __MAC_10_12 = 101200;

const int __MAC_10_12_1 = 101201;

const int __MAC_10_12_2 = 101202;

const int __MAC_10_12_4 = 101204;

const int __MAC_10_13 = 101300;

const int __MAC_10_13_1 = 101301;

const int __MAC_10_13_2 = 101302;

const int __MAC_10_13_4 = 101304;

const int __MAC_10_14 = 101400;

const int __MAC_10_14_1 = 101401;

const int __MAC_10_14_4 = 101404;

const int __MAC_10_14_5 = 101405;

const int __MAC_10_14_6 = 101406;

const int __MAC_10_15 = 101500;

const int __MAC_10_15_1 = 101501;

const int __MAC_10_15_4 = 101504;

const int __MAC_10_16 = 101600;

const int __MAC_11_0 = 110000;

const int __MAC_11_1 = 110100;

const int __MAC_11_3 = 110300;

const int __MAC_11_4 = 110400;

const int __MAC_11_5 = 110500;

const int __MAC_11_6 = 110600;

const int __MAC_12_0 = 120000;

const int __MAC_12_1 = 120100;

const int __MAC_12_2 = 120200;

const int __MAC_12_3 = 120300;

const int __MAC_12_4 = 120400;

const int __MAC_12_5 = 120500;

const int __MAC_12_6 = 120600;

const int __MAC_12_7 = 120700;

const int __MAC_13_0 = 130000;

const int __MAC_13_1 = 130100;

const int __MAC_13_2 = 130200;

const int __MAC_13_3 = 130300;

const int __MAC_13_4 = 130400;

const int __MAC_13_5 = 130500;

const int __MAC_13_6 = 130600;

const int __MAC_14_0 = 140000;

const int __MAC_14_1 = 140100;

const int __MAC_14_2 = 140200;

const int __MAC_14_3 = 140300;

const int __MAC_14_4 = 140400;

const int __MAC_14_5 = 140500;

const int __MAC_15_0 = 150000;

const int __MAC_15_1 = 150100;

const int __MAC_15_2 = 150200;

const int __IPHONE_2_0 = 20000;

const int __IPHONE_2_1 = 20100;

const int __IPHONE_2_2 = 20200;

const int __IPHONE_3_0 = 30000;

const int __IPHONE_3_1 = 30100;

const int __IPHONE_3_2 = 30200;

const int __IPHONE_4_0 = 40000;

const int __IPHONE_4_1 = 40100;

const int __IPHONE_4_2 = 40200;

const int __IPHONE_4_3 = 40300;

const int __IPHONE_5_0 = 50000;

const int __IPHONE_5_1 = 50100;

const int __IPHONE_6_0 = 60000;

const int __IPHONE_6_1 = 60100;

const int __IPHONE_7_0 = 70000;

const int __IPHONE_7_1 = 70100;

const int __IPHONE_8_0 = 80000;

const int __IPHONE_8_1 = 80100;

const int __IPHONE_8_2 = 80200;

const int __IPHONE_8_3 = 80300;

const int __IPHONE_8_4 = 80400;

const int __IPHONE_9_0 = 90000;

const int __IPHONE_9_1 = 90100;

const int __IPHONE_9_2 = 90200;

const int __IPHONE_9_3 = 90300;

const int __IPHONE_10_0 = 100000;

const int __IPHONE_10_1 = 100100;

const int __IPHONE_10_2 = 100200;

const int __IPHONE_10_3 = 100300;

const int __IPHONE_11_0 = 110000;

const int __IPHONE_11_1 = 110100;

const int __IPHONE_11_2 = 110200;

const int __IPHONE_11_3 = 110300;

const int __IPHONE_11_4 = 110400;

const int __IPHONE_12_0 = 120000;

const int __IPHONE_12_1 = 120100;

const int __IPHONE_12_2 = 120200;

const int __IPHONE_12_3 = 120300;

const int __IPHONE_12_4 = 120400;

const int __IPHONE_13_0 = 130000;

const int __IPHONE_13_1 = 130100;

const int __IPHONE_13_2 = 130200;

const int __IPHONE_13_3 = 130300;

const int __IPHONE_13_4 = 130400;

const int __IPHONE_13_5 = 130500;

const int __IPHONE_13_6 = 130600;

const int __IPHONE_13_7 = 130700;

const int __IPHONE_14_0 = 140000;

const int __IPHONE_14_1 = 140100;

const int __IPHONE_14_2 = 140200;

const int __IPHONE_14_3 = 140300;

const int __IPHONE_14_5 = 140500;

const int __IPHONE_14_4 = 140400;

const int __IPHONE_14_6 = 140600;

const int __IPHONE_14_7 = 140700;

const int __IPHONE_14_8 = 140800;

const int __IPHONE_15_0 = 150000;

const int __IPHONE_15_1 = 150100;

const int __IPHONE_15_2 = 150200;

const int __IPHONE_15_3 = 150300;

const int __IPHONE_15_4 = 150400;

const int __IPHONE_15_5 = 150500;

const int __IPHONE_15_6 = 150600;

const int __IPHONE_15_7 = 150700;

const int __IPHONE_15_8 = 150800;

const int __IPHONE_16_0 = 160000;

const int __IPHONE_16_1 = 160100;

const int __IPHONE_16_2 = 160200;

const int __IPHONE_16_3 = 160300;

const int __IPHONE_16_4 = 160400;

const int __IPHONE_16_5 = 160500;

const int __IPHONE_16_6 = 160600;

const int __IPHONE_16_7 = 160700;

const int __IPHONE_17_0 = 170000;

const int __IPHONE_17_1 = 170100;

const int __IPHONE_17_2 = 170200;

const int __IPHONE_17_3 = 170300;

const int __IPHONE_17_4 = 170400;

const int __IPHONE_17_5 = 170500;

const int __IPHONE_18_0 = 180000;

const int __IPHONE_18_1 = 180100;

const int __IPHONE_18_2 = 180200;

const int __WATCHOS_1_0 = 10000;

const int __WATCHOS_2_0 = 20000;

const int __WATCHOS_2_1 = 20100;

const int __WATCHOS_2_2 = 20200;

const int __WATCHOS_3_0 = 30000;

const int __WATCHOS_3_1 = 30100;

const int __WATCHOS_3_1_1 = 30101;

const int __WATCHOS_3_2 = 30200;

const int __WATCHOS_4_0 = 40000;

const int __WATCHOS_4_1 = 40100;

const int __WATCHOS_4_2 = 40200;

const int __WATCHOS_4_3 = 40300;

const int __WATCHOS_5_0 = 50000;

const int __WATCHOS_5_1 = 50100;

const int __WATCHOS_5_2 = 50200;

const int __WATCHOS_5_3 = 50300;

const int __WATCHOS_6_0 = 60000;

const int __WATCHOS_6_1 = 60100;

const int __WATCHOS_6_2 = 60200;

const int __WATCHOS_7_0 = 70000;

const int __WATCHOS_7_1 = 70100;

const int __WATCHOS_7_2 = 70200;

const int __WATCHOS_7_3 = 70300;

const int __WATCHOS_7_4 = 70400;

const int __WATCHOS_7_5 = 70500;

const int __WATCHOS_7_6 = 70600;

const int __WATCHOS_8_0 = 80000;

const int __WATCHOS_8_1 = 80100;

const int __WATCHOS_8_3 = 80300;

const int __WATCHOS_8_4 = 80400;

const int __WATCHOS_8_5 = 80500;

const int __WATCHOS_8_6 = 80600;

const int __WATCHOS_8_7 = 80700;

const int __WATCHOS_8_8 = 80800;

const int __WATCHOS_9_0 = 90000;

const int __WATCHOS_9_1 = 90100;

const int __WATCHOS_9_2 = 90200;

const int __WATCHOS_9_3 = 90300;

const int __WATCHOS_9_4 = 90400;

const int __WATCHOS_9_5 = 90500;

const int __WATCHOS_9_6 = 90600;

const int __WATCHOS_10_0 = 100000;

const int __WATCHOS_10_1 = 100100;

const int __WATCHOS_10_2 = 100200;

const int __WATCHOS_10_3 = 100300;

const int __WATCHOS_10_4 = 100400;

const int __WATCHOS_10_5 = 100500;

const int __WATCHOS_11_0 = 110000;

const int __WATCHOS_11_1 = 110100;

const int __WATCHOS_11_2 = 110200;

const int __TVOS_9_0 = 90000;

const int __TVOS_9_1 = 90100;

const int __TVOS_9_2 = 90200;

const int __TVOS_10_0 = 100000;

const int __TVOS_10_0_1 = 100001;

const int __TVOS_10_1 = 100100;

const int __TVOS_10_2 = 100200;

const int __TVOS_11_0 = 110000;

const int __TVOS_11_1 = 110100;

const int __TVOS_11_2 = 110200;

const int __TVOS_11_3 = 110300;

const int __TVOS_11_4 = 110400;

const int __TVOS_12_0 = 120000;

const int __TVOS_12_1 = 120100;

const int __TVOS_12_2 = 120200;

const int __TVOS_12_3 = 120300;

const int __TVOS_12_4 = 120400;

const int __TVOS_13_0 = 130000;

const int __TVOS_13_2 = 130200;

const int __TVOS_13_3 = 130300;

const int __TVOS_13_4 = 130400;

const int __TVOS_14_0 = 140000;

const int __TVOS_14_1 = 140100;

const int __TVOS_14_2 = 140200;

const int __TVOS_14_3 = 140300;

const int __TVOS_14_5 = 140500;

const int __TVOS_14_6 = 140600;

const int __TVOS_14_7 = 140700;

const int __TVOS_15_0 = 150000;

const int __TVOS_15_1 = 150100;

const int __TVOS_15_2 = 150200;

const int __TVOS_15_3 = 150300;

const int __TVOS_15_4 = 150400;

const int __TVOS_15_5 = 150500;

const int __TVOS_15_6 = 150600;

const int __TVOS_16_0 = 160000;

const int __TVOS_16_1 = 160100;

const int __TVOS_16_2 = 160200;

const int __TVOS_16_3 = 160300;

const int __TVOS_16_4 = 160400;

const int __TVOS_16_5 = 160500;

const int __TVOS_16_6 = 160600;

const int __TVOS_17_0 = 170000;

const int __TVOS_17_1 = 170100;

const int __TVOS_17_2 = 170200;

const int __TVOS_17_3 = 170300;

const int __TVOS_17_4 = 170400;

const int __TVOS_17_5 = 170500;

const int __TVOS_18_0 = 180000;

const int __TVOS_18_1 = 180100;

const int __TVOS_18_2 = 180200;

const int __BRIDGEOS_2_0 = 20000;

const int __BRIDGEOS_3_0 = 30000;

const int __BRIDGEOS_3_1 = 30100;

const int __BRIDGEOS_3_4 = 30400;

const int __BRIDGEOS_4_0 = 40000;

const int __BRIDGEOS_4_1 = 40100;

const int __BRIDGEOS_5_0 = 50000;

const int __BRIDGEOS_5_1 = 50100;

const int __BRIDGEOS_5_3 = 50300;

const int __BRIDGEOS_6_0 = 60000;

const int __BRIDGEOS_6_2 = 60200;

const int __BRIDGEOS_6_4 = 60400;

const int __BRIDGEOS_6_5 = 60500;

const int __BRIDGEOS_6_6 = 60600;

const int __BRIDGEOS_7_0 = 70000;

const int __BRIDGEOS_7_1 = 70100;

const int __BRIDGEOS_7_2 = 70200;

const int __BRIDGEOS_7_3 = 70300;

const int __BRIDGEOS_7_4 = 70400;

const int __BRIDGEOS_7_6 = 70600;

const int __BRIDGEOS_8_0 = 80000;

const int __BRIDGEOS_8_1 = 80100;

const int __BRIDGEOS_8_2 = 80200;

const int __BRIDGEOS_8_3 = 80300;

const int __BRIDGEOS_8_4 = 80400;

const int __BRIDGEOS_8_5 = 80500;

const int __BRIDGEOS_9_0 = 90000;

const int __BRIDGEOS_9_1 = 90100;

const int __BRIDGEOS_9_2 = 90200;

const int __DRIVERKIT_19_0 = 190000;

const int __DRIVERKIT_20_0 = 200000;

const int __DRIVERKIT_21_0 = 210000;

const int __DRIVERKIT_22_0 = 220000;

const int __DRIVERKIT_22_4 = 220400;

const int __DRIVERKIT_22_5 = 220500;

const int __DRIVERKIT_22_6 = 220600;

const int __DRIVERKIT_23_0 = 230000;

const int __DRIVERKIT_23_1 = 230100;

const int __DRIVERKIT_23_2 = 230200;

const int __DRIVERKIT_23_3 = 230300;

const int __DRIVERKIT_23_4 = 230400;

const int __DRIVERKIT_23_5 = 230500;

const int __DRIVERKIT_24_0 = 240000;

const int __DRIVERKIT_24_1 = 240100;

const int __DRIVERKIT_24_2 = 240200;

const int __VISIONOS_1_0 = 10000;

const int __VISIONOS_1_1 = 10100;

const int __VISIONOS_1_2 = 10200;

const int __VISIONOS_2_0 = 20000;

const int __VISIONOS_2_1 = 20100;

const int __VISIONOS_2_2 = 20200;

const int MAC_OS_X_VERSION_10_0 = 1000;

const int MAC_OS_X_VERSION_10_1 = 1010;

const int MAC_OS_X_VERSION_10_2 = 1020;

const int MAC_OS_X_VERSION_10_3 = 1030;

const int MAC_OS_X_VERSION_10_4 = 1040;

const int MAC_OS_X_VERSION_10_5 = 1050;

const int MAC_OS_X_VERSION_10_6 = 1060;

const int MAC_OS_X_VERSION_10_7 = 1070;

const int MAC_OS_X_VERSION_10_8 = 1080;

const int MAC_OS_X_VERSION_10_9 = 1090;

const int MAC_OS_X_VERSION_10_10 = 101000;

const int MAC_OS_X_VERSION_10_10_2 = 101002;

const int MAC_OS_X_VERSION_10_10_3 = 101003;

const int MAC_OS_X_VERSION_10_11 = 101100;

const int MAC_OS_X_VERSION_10_11_2 = 101102;

const int MAC_OS_X_VERSION_10_11_3 = 101103;

const int MAC_OS_X_VERSION_10_11_4 = 101104;

const int MAC_OS_X_VERSION_10_12 = 101200;

const int MAC_OS_X_VERSION_10_12_1 = 101201;

const int MAC_OS_X_VERSION_10_12_2 = 101202;

const int MAC_OS_X_VERSION_10_12_4 = 101204;

const int MAC_OS_X_VERSION_10_13 = 101300;

const int MAC_OS_X_VERSION_10_13_1 = 101301;

const int MAC_OS_X_VERSION_10_13_2 = 101302;

const int MAC_OS_X_VERSION_10_13_4 = 101304;

const int MAC_OS_X_VERSION_10_14 = 101400;

const int MAC_OS_X_VERSION_10_14_1 = 101401;

const int MAC_OS_X_VERSION_10_14_4 = 101404;

const int MAC_OS_X_VERSION_10_14_5 = 101405;

const int MAC_OS_X_VERSION_10_14_6 = 101406;

const int MAC_OS_X_VERSION_10_15 = 101500;

const int MAC_OS_X_VERSION_10_15_1 = 101501;

const int MAC_OS_X_VERSION_10_15_4 = 101504;

const int MAC_OS_X_VERSION_10_16 = 101600;

const int MAC_OS_VERSION_11_0 = 110000;

const int MAC_OS_VERSION_11_1 = 110100;

const int MAC_OS_VERSION_11_3 = 110300;

const int MAC_OS_VERSION_11_4 = 110400;

const int MAC_OS_VERSION_11_5 = 110500;

const int MAC_OS_VERSION_11_6 = 110600;

const int MAC_OS_VERSION_12_0 = 120000;

const int MAC_OS_VERSION_12_1 = 120100;

const int MAC_OS_VERSION_12_2 = 120200;

const int MAC_OS_VERSION_12_3 = 120300;

const int MAC_OS_VERSION_12_4 = 120400;

const int MAC_OS_VERSION_12_5 = 120500;

const int MAC_OS_VERSION_12_6 = 120600;

const int MAC_OS_VERSION_12_7 = 120700;

const int MAC_OS_VERSION_13_0 = 130000;

const int MAC_OS_VERSION_13_1 = 130100;

const int MAC_OS_VERSION_13_2 = 130200;

const int MAC_OS_VERSION_13_3 = 130300;

const int MAC_OS_VERSION_13_4 = 130400;

const int MAC_OS_VERSION_13_5 = 130500;

const int MAC_OS_VERSION_13_6 = 130600;

const int MAC_OS_VERSION_14_0 = 140000;

const int MAC_OS_VERSION_14_1 = 140100;

const int MAC_OS_VERSION_14_2 = 140200;

const int MAC_OS_VERSION_14_3 = 140300;

const int MAC_OS_VERSION_14_4 = 140400;

const int MAC_OS_VERSION_14_5 = 140500;

const int MAC_OS_VERSION_15_0 = 150000;

const int MAC_OS_VERSION_15_1 = 150100;

const int MAC_OS_VERSION_15_2 = 150200;

const int __MAC_OS_X_VERSION_MIN_REQUIRED = 150000;

const int __MAC_OS_X_VERSION_MAX_ALLOWED = 150200;

const int __ENABLE_LEGACY_MAC_AVAILABILITY = 1;

const int __has_safe_buffers = 1;

const int __DARWIN_ONLY_64_BIT_INO_T = 1;

const int __DARWIN_ONLY_UNIX_CONFORMANCE = 1;

const int __DARWIN_ONLY_VERS_1050 = 1;

const int __DARWIN_UNIX03 = 1;

const int __DARWIN_64_BIT_INO_T = 1;

const int __DARWIN_VERS_1050 = 1;

const int __DARWIN_NON_CANCELABLE = 0;

const String __DARWIN_SUF_EXTSN = '\$DARWIN_EXTSN';

const int __DARWIN_C_ANSI = 4096;

const int __DARWIN_C_FULL = 900000;

const int __DARWIN_C_LEVEL = 900000;

const int __STDC_WANT_LIB_EXT1__ = 1;

const int __DARWIN_NO_LONG_LONG = 0;

const int _DARWIN_FEATURE_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_VERS_1050 = 1;

const int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = 1;

const int _DARWIN_FEATURE_UNIX_CONFORMANCE = 3;

const int __has_ptrcheck = 0;

const int __DARWIN_NULL = 0;

const int __PTHREAD_SIZE__ = 8176;

const int __PTHREAD_ATTR_SIZE__ = 56;

const int __PTHREAD_MUTEXATTR_SIZE__ = 8;

const int __PTHREAD_MUTEX_SIZE__ = 56;

const int __PTHREAD_CONDATTR_SIZE__ = 8;

const int __PTHREAD_COND_SIZE__ = 40;

const int __PTHREAD_ONCE_SIZE__ = 8;

const int __PTHREAD_RWLOCK_SIZE__ = 192;

const int __PTHREAD_RWLOCKATTR_SIZE__ = 16;

const int __DARWIN_WCHAR_MAX = 2147483647;

const int __DARWIN_WCHAR_MIN = -2147483648;

const int __DARWIN_WEOF = -1;

const int _FORTIFY_SOURCE = 2;

const int __DARWIN_NSIG = 32;

const int NSIG = 32;

const int _ARM_SIGNAL_ = 1;

const int SIGHUP = 1;

const int SIGINT = 2;

const int SIGQUIT = 3;

const int SIGILL = 4;

const int SIGTRAP = 5;

const int SIGABRT = 6;

const int SIGIOT = 6;

const int SIGEMT = 7;

const int SIGFPE = 8;

const int SIGKILL = 9;

const int SIGBUS = 10;

const int SIGSEGV = 11;

const int SIGSYS = 12;

const int SIGPIPE = 13;

const int SIGALRM = 14;

const int SIGTERM = 15;

const int SIGURG = 16;

const int SIGSTOP = 17;

const int SIGTSTP = 18;

const int SIGCONT = 19;

const int SIGCHLD = 20;

const int SIGTTIN = 21;

const int SIGTTOU = 22;

const int SIGIO = 23;

const int SIGXCPU = 24;

const int SIGXFSZ = 25;

const int SIGVTALRM = 26;

const int SIGPROF = 27;

const int SIGWINCH = 28;

const int SIGINFO = 29;

const int SIGUSR1 = 30;

const int SIGUSR2 = 31;

const int USER_ADDR_NULL = 0;

const int __DARWIN_OPAQUE_ARM_THREAD_STATE64 = 0;

const int SIGEV_NONE = 0;

const int SIGEV_SIGNAL = 1;

const int SIGEV_THREAD = 3;

const int ILL_NOOP = 0;

const int ILL_ILLOPC = 1;

const int ILL_ILLTRP = 2;

const int ILL_PRVOPC = 3;

const int ILL_ILLOPN = 4;

const int ILL_ILLADR = 5;

const int ILL_PRVREG = 6;

const int ILL_COPROC = 7;

const int ILL_BADSTK = 8;

const int FPE_NOOP = 0;

const int FPE_FLTDIV = 1;

const int FPE_FLTOVF = 2;

const int FPE_FLTUND = 3;

const int FPE_FLTRES = 4;

const int FPE_FLTINV = 5;

const int FPE_FLTSUB = 6;

const int FPE_INTDIV = 7;

const int FPE_INTOVF = 8;

const int SEGV_NOOP = 0;

const int SEGV_MAPERR = 1;

const int SEGV_ACCERR = 2;

const int BUS_NOOP = 0;

const int BUS_ADRALN = 1;

const int BUS_ADRERR = 2;

const int BUS_OBJERR = 3;

const int TRAP_BRKPT = 1;

const int TRAP_TRACE = 2;

const int CLD_NOOP = 0;

const int CLD_EXITED = 1;

const int CLD_KILLED = 2;

const int CLD_DUMPED = 3;

const int CLD_TRAPPED = 4;

const int CLD_STOPPED = 5;

const int CLD_CONTINUED = 6;

const int POLL_IN = 1;

const int POLL_OUT = 2;

const int POLL_MSG = 3;

const int POLL_ERR = 4;

const int POLL_PRI = 5;

const int POLL_HUP = 6;

const int SA_ONSTACK = 1;

const int SA_RESTART = 2;

const int SA_RESETHAND = 4;

const int SA_NOCLDSTOP = 8;

const int SA_NODEFER = 16;

const int SA_NOCLDWAIT = 32;

const int SA_SIGINFO = 64;

const int SA_USERTRAMP = 256;

const int SA_64REGSET = 512;

const int SA_USERSPACE_MASK = 127;

const int SIG_BLOCK = 1;

const int SIG_UNBLOCK = 2;

const int SIG_SETMASK = 3;

const int SI_USER = 65537;

const int SI_QUEUE = 65538;

const int SI_TIMER = 65539;

const int SI_ASYNCIO = 65540;

const int SI_MESGQ = 65541;

const int SS_ONSTACK = 1;

const int SS_DISABLE = 4;

const int MINSIGSTKSZ = 32768;

const int SIGSTKSZ = 131072;

const int SV_ONSTACK = 1;

const int SV_INTERRUPT = 2;

const int SV_RESETHAND = 4;

const int SV_NODEFER = 16;

const int SV_NOCLDSTOP = 8;

const int SV_SIGINFO = 64;

const int __WORDSIZE = 64;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -32768;

const int INT_FAST32_MIN = -2147483648;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 32767;

const int INT_FAST32_MAX = 2147483647;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = 65535;

const int UINT_FAST32_MAX = 4294967295;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MAX = 9223372036854775807;

const int INTPTR_MIN = -9223372036854775808;

const int UINTPTR_MAX = -1;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIZE_MAX = -1;

const int RSIZE_MAX = 9223372036854775807;

const int WCHAR_MAX = 2147483647;

const int WCHAR_MIN = -2147483648;

const int WINT_MIN = -2147483648;

const int WINT_MAX = 2147483647;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int PRIO_PROCESS = 0;

const int PRIO_PGRP = 1;

const int PRIO_USER = 2;

const int PRIO_DARWIN_THREAD = 3;

const int PRIO_DARWIN_PROCESS = 4;

const int PRIO_MIN = -20;

const int PRIO_MAX = 20;

const int PRIO_DARWIN_BG = 4096;

const int PRIO_DARWIN_NONUI = 4097;

const int RUSAGE_SELF = 0;

const int RUSAGE_CHILDREN = -1;

const int RUSAGE_INFO_V0 = 0;

const int RUSAGE_INFO_V1 = 1;

const int RUSAGE_INFO_V2 = 2;

const int RUSAGE_INFO_V3 = 3;

const int RUSAGE_INFO_V4 = 4;

const int RUSAGE_INFO_V5 = 5;

const int RUSAGE_INFO_V6 = 6;

const int RUSAGE_INFO_CURRENT = 6;

const int RU_PROC_RUNS_RESLIDE = 1;

const int RLIM_INFINITY = 9223372036854775807;

const int RLIM_SAVED_MAX = 9223372036854775807;

const int RLIM_SAVED_CUR = 9223372036854775807;

const int RLIMIT_CPU = 0;

const int RLIMIT_FSIZE = 1;

const int RLIMIT_DATA = 2;

const int RLIMIT_STACK = 3;

const int RLIMIT_CORE = 4;

const int RLIMIT_AS = 5;

const int RLIMIT_RSS = 5;

const int RLIMIT_MEMLOCK = 6;

const int RLIMIT_NPROC = 7;

const int RLIMIT_NOFILE = 8;

const int RLIM_NLIMITS = 9;

const int _RLIMIT_POSIX_FLAG = 4096;

const int RLIMIT_WAKEUPS_MONITOR = 1;

const int RLIMIT_CPU_USAGE_MONITOR = 2;

const int RLIMIT_THREAD_CPULIMITS = 3;

const int RLIMIT_FOOTPRINT_INTERVAL = 4;

const int WAKEMON_ENABLE = 1;

const int WAKEMON_DISABLE = 2;

const int WAKEMON_GET_PARAMS = 4;

const int WAKEMON_SET_DEFAULTS = 8;

const int WAKEMON_MAKE_FATAL = 16;

const int CPUMON_MAKE_FATAL = 4096;

const int FOOTPRINT_INTERVAL_RESET = 1;

const int IOPOL_TYPE_DISK = 0;

const int IOPOL_TYPE_VFS_ATIME_UPDATES = 2;

const int IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES = 3;

const int IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME = 4;

const int IOPOL_TYPE_VFS_TRIGGER_RESOLVE = 5;

const int IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION = 6;

const int IOPOL_TYPE_VFS_IGNORE_PERMISSIONS = 7;

const int IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE = 8;

const int IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES = 9;

const int IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY = 10;

const int IOPOL_SCOPE_PROCESS = 0;

const int IOPOL_SCOPE_THREAD = 1;

const int IOPOL_SCOPE_DARWIN_BG = 2;

const int IOPOL_DEFAULT = 0;

const int IOPOL_IMPORTANT = 1;

const int IOPOL_PASSIVE = 2;

const int IOPOL_THROTTLE = 3;

const int IOPOL_UTILITY = 4;

const int IOPOL_STANDARD = 5;

const int IOPOL_APPLICATION = 5;

const int IOPOL_NORMAL = 1;

const int IOPOL_ATIME_UPDATES_DEFAULT = 0;

const int IOPOL_ATIME_UPDATES_OFF = 1;

const int IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT = 0;

const int IOPOL_MATERIALIZE_DATALESS_FILES_OFF = 1;

const int IOPOL_MATERIALIZE_DATALESS_FILES_ON = 2;

const int IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT = 0;

const int IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME = 1;

const int IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT = 0;

const int IOPOL_VFS_TRIGGER_RESOLVE_OFF = 1;

const int IOPOL_VFS_CONTENT_PROTECTION_DEFAULT = 0;

const int IOPOL_VFS_CONTENT_PROTECTION_IGNORE = 1;

const int IOPOL_VFS_IGNORE_PERMISSIONS_OFF = 0;

const int IOPOL_VFS_IGNORE_PERMISSIONS_ON = 1;

const int IOPOL_VFS_SKIP_MTIME_UPDATE_OFF = 0;

const int IOPOL_VFS_SKIP_MTIME_UPDATE_ON = 1;

const int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF = 0;

const int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON = 1;

const int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT = 0;

const int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON = 1;

const int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT = 0;

const int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON = 1;

const int WNOHANG = 1;

const int WUNTRACED = 2;

const int WCOREFLAG = 128;

const int _WSTOPPED = 127;

const int WEXITED = 4;

const int WSTOPPED = 8;

const int WCONTINUED = 16;

const int WNOWAIT = 32;

const int WAIT_ANY = -1;

const int WAIT_MYPGRP = 0;

const int _QUAD_HIGHWORD = 1;

const int _QUAD_LOWWORD = 0;

const int __DARWIN_LITTLE_ENDIAN = 1234;

const int __DARWIN_BIG_ENDIAN = 4321;

const int __DARWIN_PDP_ENDIAN = 3412;

const int LITTLE_ENDIAN = 1234;

const int BIG_ENDIAN = 4321;

const int PDP_ENDIAN = 3412;

const int __DARWIN_BYTE_ORDER = 1234;

const int BYTE_ORDER = 1234;

const int NULL = 0;

const int EXIT_FAILURE = 1;

const int EXIT_SUCCESS = 0;

const int RAND_MAX = 2147483647;

const int __bool_true_false_are_defined = 1;

const int true1 = 1;

const int false1 = 0;

const int TREE_SITTER_LANGUAGE_VERSION = 15;

const int TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION = 13;
